{"meta":{"title":"逸如风的个人博客","subtitle":"","description":"123","author":"yirufeng","url":"http://www.sivan.tech","root":"/"},"pages":[{"title":"","date":"2022-09-28T06:20:08.864Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"about/index.html","permalink":"http://www.sivan.tech/about/index.html","excerpt":"","text":"🐶浪开发者，坐标武汉 广埠屯断水停电大学在读研究生 爱好电子设备以及电音 ecLGa6 关于我IMG_1414IMG_1415IMG_1416 实践经历实践经历 2021.05 - now 阿里云计算有限公司 - 云网络 2019.09 - now 教育大数据应用技术国家工程实验室 - 认知计算实验室 2017.09 - 2019.06 Let’s try 社团技术指导委员会成员 2017.07 - 2018.07 湖南青创客网络科技有限公司项目经理 2017.09 - 2017.11 软件新技术研究组副组长(机器学习方向) 2015.10 - 2017.09 计算机学院创新创业实验室项目组(校内ACM竞赛选拔) 博客经历 2020.09（更换现有主题） 更换博客主题 2019.08（博客挂掉，改用hexo） 使用hexo + travis CI 自动集成部署博客 2016.09（使用WordPress） 使用WordPress搭建自己的第一个博客 那些鼓励我的话吃学习的苦，不吃生活的苦。 有一句话是“遍地都是六便士，他却抬头看月亮”。这句话的意思是，人要克制对唾手可得的实际利益的诱惑，要有一种超越性的、更宽阔的眼界。有时候，抬头看月亮，是多么奢侈的一件事啊，因为利益的羁绊，不是那么容易破掉的，尤其是生活在承受重负之时。另一句话是：“我用尽了毕生的力气，只是抵达了生活的平凡”。这句话中包含的力量，正好与前一句形成互补。 将有必死之心，士无偷生之念。 只有杀敌的军人，没有屈膝的将军。 故今日责任，不在他人，就在少年，少年强则国强，少年富则国富 我欲望着他人的欲望 种一棵树最好的时间是十年前，其次是现在 唯有自强不息，我们才会有日后的无限可能。” 一个成器的孩子，不仅仅带给父母喜悦，甚至还寄托着他们的尊严。 没有什么通过努力做不到的，如果有那就是不够努力 世上所有的奇迹，都源于努力 岂能尽如人意，但求无愧于心 专注 年轻人可以把多余的时间和精力，专注到自己喜欢做的事情上。 当一个人自律到极致的时候，即便你起点不高，即便你受尽嘲讽，全世界依旧会为你让路。 人生没有寒暑假，不是成功来得不够快，而是对自己不够狠 成功从来没有捷径，努力的人从来不会被辜负 世上所有的牛逼，闻起来，其实都是加班的味道！有人问美国“篮球天才”科比为何如此成功？他反问道：“你知道洛杉矶每天早上4点钟是什么样子吗？”这个世界上最可怕的事：那些比你聪明的人，比你更努力 世上只有一种投资只赚不赔，那就是学习。莫言曾经说过：当你的才华还撑不起你的野心的时候，你就应该静下心来学习，当你的能力还驾驭不了你的目标时，就应该沉下心来历练；从来没有人因为学习而倾家荡产，但一定有人因为不学习而一贫如洗；从来没有人因为学习而越学越贫穷，但一定有人因为学习而走向成功。 计算机科学也不能保证让你一辈子没有遗憾，但是它有可能，帮助你实现贝佐斯（亚马逊CEO）追求的目标：把认识当中的遗憾降到最少 为了避免平庸，要拒绝拉着你走向平庸的那些压力、诱惑，大多数人无法做到，但张一鸣做到了。 主动选择的时候，用排列组合，做出最优解；被动的放弃的时刻，用算法设计，选择最好的结果。 如果世界上真的有奇迹，那只是努力的另一个名字。愿披星戴月的你，终将凯旋。 人若有志，万事可为如果你年轻的时候学不会思考，那就永远不会 心能拘束，身何拘束 唯努力不负人。 要么死的安然，要么活的絢烂 我，有个职业病，看到美的东西就想拍下来。 这个世界上没有天才，只有不努力的笨蛋 做自己觉得有意义且正确的事情，不浪费时间在不相关的人和事情身上，这大概就是快乐的开关吧。 那些挥舞的泪水永远不会白流 别让别人告诉你，你也成不了才，如果你有梦想的话，就要去捍卫它，那些一事无成的人，想告诉你，你也成不了才。 每一个不曾起舞的日子，都是对生命的辜负。 你可以一无所有，但不可以一无是处 人生处处是缘分，无论你去了哪里，都是冥冥中自有天意，所以不要太在意自己去了哪里，现在生活怎么样，无论你去了国际大厂，还是去了国内中小企业，这都是你的缘分，就像你出生在什么样的家庭，拥有着什么样的智商，都是自己和家人和企业和这个世界的缘分，当你以为与某个企业应该有缘分，但是最终却没有收获到对应的缘分，不必叹息，又或当你与哪个女孩子，男孩子错过，也不要感叹，这都是我们的缘分，我们只需做好自己，打好手中已有的牌。不过如果你心中有个情节，你想和哪个姑娘发生缘分..哦对不起我帮不了你。但是如果你想跟字节发生一些缘分，我可以助力你一把。快来吧! 最后希望你与我也可以发生缘分（投递）。 你会经历一段难以置信、跌宕起伏的旅程。你会遇到很多志同道合的好友，以及你十分尊敬的师长。虽然你也会走很多弯路，碰到很多困难与挫折，但是不要担心，你一直兢兢业业、勤勉刻苦，你的努力最终都会得到回报 愿你历尽千帆，终能得偿所愿。 如果我走到人生十字路口，我知道哪条路是对的， 毫无例外，我就知道，但我从不走，为什么？因为妈的太苦了。 别让别人告诉你，你成不了才。如果你有梦想的话，就要去捍卫它。 把手握紧，厚积薄发，你，只有付出，付出你的时间，赌上你的尊严，拿出你的全部，当别人打游戏时你在学习，当别人睡懒觉时你在学习，你含着泪在深夜里舞蹈，在回忆里奔跑，没有人在年少时想成为一个普通人。尽管生活，它会剥夺你的所爱践踏你的尊严，把你踩在脚下遍体鳞伤，但你怎能倒下？但你身后是你的挚爱，那些曾受过的伤，都是你送给未来自己最好的礼物。 正如巴尔扎克在人间喜剧中所言，革新者全靠了不起的信心支持，才有勇气在不可知的天地中前进。（But as Balzac said in The Human Comedy: The innovator is supported by great confidence. To have the courage to move forward in the unknown.） 我现在之所以这么努力，我就是希望，能够在我飞黄腾达的时候，你还没有谈婚论嫁，我希望一切，还来得及。 总有一忍，值得你期待，值得你全力以赴。 须知少时凌云志，曽许人间第一流。 在繁华中自律，在落魄中自愈，谋生的路上不抛弃良知，某次的路上不丢失尊严。 梦想一旦开始，便无法停止，那一刻就是我们热爱的理由，年轻这个借口不知道还能用多久。 意志足够坚定，没有什么不可以。 樱花落下的速度是每秒五厘米，我该用什么样的速度才能与你相遇。 你必须非常努力才能看起来毫不费力，路不坦荡，那就活成自己"},{"title":"archives","date":"2020-09-19T15:23:53.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"archives/index.html","permalink":"http://www.sivan.tech/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-09-19T15:19:19.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"categories/index.html","permalink":"http://www.sivan.tech/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-28T06:20:08.864Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"friends/index.html","permalink":"http://www.sivan.tech/friends/index.html","excerpt":"","text":"一些课程推荐 极客时间的《Go进阶训练营》 一些技术团队博客汇总 wego 公众号 码农桃花源 码洞 开发内功修炼 TechPaper(曹大的微信公众号，曹大的博客：https://xargin.com/) Golang Contributor Club bilibili_up主推荐 go夜读 Go杂志 A journel with go Go101 书籍 go高级编程 go语言设计与实现 go学习笔记 曹大的go从源码到应用 《Go入门指南》 无闻老师的课程：https://study.163.com/course/courseLearn.htm?courseId=306002#/learn/video?lessonId=421024&amp;courseId=306002 Go101 go进阶 曹大的源码分析 Go语言设计与实现 Go语言原本 深度阅读之&lt;&gt; Mastering Go Go101 （饶神 + 曹大 + 鸟窝 + Golang Contributor Club）的文章"},{"title":"","date":"2022-09-28T06:20:08.864Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"pictures/index.html","permalink":"http://www.sivan.tech/pictures/index.html","excerpt":"","text":"图集时间线 2021.10.27 _CHN4281_CHN4228_CHN4192_CHN4191_CHN4187_CHN4184_CHN4182_CHN4157_CHN4148_CHN4135 2021.10.24 _CHN3631_CHN3890_CHN3896_CHN3854_CHN3855_CHN3866_CHN3844_CHN3952_CHN3938_CHN3924_CHN3920_CHN3916_CHN3914_CHN3906_CHN3905_CHN3899 2021.10.14 _CHN3134_CHN3083_CHN3080_CHN3092_CHN3099_CHN3117 2021.10.03 DSC00435DSC00564DSC00740DSC00731DSC00552DSC00496DSC00461DSC00458DSC00453"},{"title":"开源项目","date":"2020-09-19T18:04:18.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"projects/index.html","permalink":"http://www.sivan.tech/projects/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-28T06:20:08.864Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"resources/index.html","permalink":"http://www.sivan.tech/resources/index.html","excerpt":"","text":"语言GoC/C++JavaRust栏目2。。。 Hacking C++，一份颇为全面的 C++ 速查表与信息图表。覆盖了算法、随机分布、序列、Lambda 表达式、设计指南等内容：点击访问 。。。。。。 查看代码测试 一脸懵逼 项目GoC/C++JavaRust前端其他 开源的文件共享系统：PicoShare，简单易用、不限制文件大小、可直接生成下载链接，支持自托管部署，数据安全性可控：点击访问 。。。。。。。。。 简历生成器：点击访问 一图胜千言：点击访问 查看代码测试 一脸懵逼 工具 开源图片水印去除解决方案：点击访问 可视化生成正则表达式：点击访问 isualize Data on Spirals，可快速搭建呈螺旋结构的可视化数据图。点击访问 JSON 可视化工具 JSON Visio：点击访问 技术书籍机器学习RustJavaRustC/C++栏目2 开源技术书籍：《机器学习系统：设计和实现》点击访问 开源技术笔记：《代码整洁之道》（Clean Code Notes），主要讲解如何编写干净、整洁的代码，合理定义代码名称、单元测试、项目数据结构等内容。点击访问 开源技术教程：《Rust 异步编程指南》点击访问 技术书籍《Rust 从零开发到上线》（Zero To Production In Rust）点击访问 《用 Rust 开发一个操作系统》：点击访问 。。。。。。 《C++ Concurrency in Action 2ed 笔记》，C++11/14/17/20 多线程，掌握操作系统原理，解锁并发编程技术。原书籍前五章介绍了线程支持库的基本用法，后六章从实践角度介绍了并发编程的设计思想。点击访问 查看代码测试 一脸懵逼 项目GoC/C++JavaRust其他。。。。。。。。。 开源技术资源：《Rust 新手入门指南》（Rust 🦀. How do I start?）点击访问。。。 一图胜千言：点击访问 比较火的头像生成器：avvvatars 点击访问 一个开源的、友好易用的监控告警系统：HertzBeat，支持网站，API，PING，端口，数据库，操作系统等监控类型，并自带可视化操作界面： 点击访问 国内开发者开发的一个菜谱网站：点击访问 查看代码测试 一脸懵逼 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试"},{"title":"所有标签","date":"2022-09-28T06:20:08.864Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"tags/index.html","permalink":"http://www.sivan.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"c语言中日期字符串转换为时间戳","slug":"c语言中日期字符串转换为时间戳","date":"2022-09-28T10:44:14.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2022/09/28/c语言中日期字符串转换为时间戳/","link":"","permalink":"http://www.sivan.tech/2022/09/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3/","excerpt":"字符串与时间戳的转换日期字符串转换为时间戳思路： 将日期字符串转换为时间结构体 将时间结构体转换为对应的时间戳(time_t类型，其实是long类型的别名) 日期字符串转换为时间戳 123456789time_t convertDateToTimestamp(const string &amp;date)&#123; // 首先在后面添加时间 char dateTimeBuf[64]; snprintf(dateTimeBuf, sizeof(dateTimeBuf), &quot;%s 00:00:00&quot;, date.c_str()); struct tm dateTM; strptime(dateTimeBuf, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTM); return mktime(&amp;dateTM);&#125; 日期时间字符串转换为时间戳思路： 将日期字符串转换为时间结构体 将时间结构体转换为对应的时间戳(time_t类型，其实是long类型的别名) 日期时间字符串转换为时间戳 1234567// 日期时间字符串转换为对应的时间戳time_t convertDatetimeToTimestamp(const string &amp;date_time)&#123; struct tm dtTM; strptime(date_time.c_str(), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dtTM); return mktime(&amp;dtTM);&#125; 时间戳转换为日期字符串思路： 将时间戳转换为struct tm类型的时间：使用localtime_r函数或者localtime函数 然后将struct tm类型的时间按照给定格式化串格式化为字符串：使用strftime函数 时间戳转换为日期字符串 1234567891011121314// 时间戳转换为日期void convertTimestampToDate(time_t timestamp, string &amp;date)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTm; localtime_r(&amp;timestamp, &amp;dateTm); printf(&quot;%d-%d-%d\\n&quot;, dateTm.tm_year + 1900, dateTm.tm_mon + 1, dateTm.tm_mday); // 2. 将struct tm类型转换为自定义格式化字符串 char dateBuf[16]; strftime(dateBuf, sizeof(dateBuf), &quot;%Y-%m-%d&quot;, &amp;dateTm); date = dateBuf;&#125; 时间戳转换为日期时间字符串思路： 将时间戳转换为struct tm类型的时间：使用localtime_r函数或者localtime函数 然后将struct tm类型的时间按照给定格式化串格式化为字符串：使用strftime函数 时间戳转换为日期时间字符串 12345678910111213// 时间戳转换为日期时间void convertTimestampToDatetime(time_t timestamp, string &amp;date_time)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTimeTm; localtime_r(&amp;timestamp, &amp;dateTimeTm); // 2. 将struct tm类型转换为自定义格式化字符串 char dateTimeBuf[32]; strftime(dateTimeBuf, sizeof(dateTimeBuf), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTimeTm); date_time = dateTimeBuf;&#125;","text":"字符串与时间戳的转换日期字符串转换为时间戳思路： 将日期字符串转换为时间结构体 将时间结构体转换为对应的时间戳(time_t类型，其实是long类型的别名) 日期字符串转换为时间戳 123456789time_t convertDateToTimestamp(const string &amp;date)&#123; // 首先在后面添加时间 char dateTimeBuf[64]; snprintf(dateTimeBuf, sizeof(dateTimeBuf), &quot;%s 00:00:00&quot;, date.c_str()); struct tm dateTM; strptime(dateTimeBuf, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTM); return mktime(&amp;dateTM);&#125; 日期时间字符串转换为时间戳思路： 将日期字符串转换为时间结构体 将时间结构体转换为对应的时间戳(time_t类型，其实是long类型的别名) 日期时间字符串转换为时间戳 1234567// 日期时间字符串转换为对应的时间戳time_t convertDatetimeToTimestamp(const string &amp;date_time)&#123; struct tm dtTM; strptime(date_time.c_str(), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dtTM); return mktime(&amp;dtTM);&#125; 时间戳转换为日期字符串思路： 将时间戳转换为struct tm类型的时间：使用localtime_r函数或者localtime函数 然后将struct tm类型的时间按照给定格式化串格式化为字符串：使用strftime函数 时间戳转换为日期字符串 1234567891011121314// 时间戳转换为日期void convertTimestampToDate(time_t timestamp, string &amp;date)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTm; localtime_r(&amp;timestamp, &amp;dateTm); printf(&quot;%d-%d-%d\\n&quot;, dateTm.tm_year + 1900, dateTm.tm_mon + 1, dateTm.tm_mday); // 2. 将struct tm类型转换为自定义格式化字符串 char dateBuf[16]; strftime(dateBuf, sizeof(dateBuf), &quot;%Y-%m-%d&quot;, &amp;dateTm); date = dateBuf;&#125; 时间戳转换为日期时间字符串思路： 将时间戳转换为struct tm类型的时间：使用localtime_r函数或者localtime函数 然后将struct tm类型的时间按照给定格式化串格式化为字符串：使用strftime函数 时间戳转换为日期时间字符串 12345678910111213// 时间戳转换为日期时间void convertTimestampToDatetime(time_t timestamp, string &amp;date_time)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTimeTm; localtime_r(&amp;timestamp, &amp;dateTimeTm); // 2. 将struct tm类型转换为自定义格式化字符串 char dateTimeBuf[32]; strftime(dateTimeBuf, sizeof(dateTimeBuf), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTimeTm); date_time = dateTimeBuf;&#125; 参考文章 【C语言笔记】时间日期函数 【笔记】整理C语言的时间函数 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;using namespace std;// 日期字符串转换为对应的时间戳time_t convertDateToTimestamp(const string &amp;date)&#123; // 首先在后面添加时间 char dateTimeBuf[64]; snprintf(dateTimeBuf, sizeof(dateTimeBuf), &quot;%s 00:00:00&quot;, date.c_str()); struct tm dateTM; strptime(dateTimeBuf, &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTM); return mktime(&amp;dateTM);&#125;// 日期时间字符串转换为对应的时间戳time_t convertDatetimeToTimestamp(const string &amp;date_time)&#123; struct tm dtTM; strptime(date_time.c_str(), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dtTM); return mktime(&amp;dtTM);&#125;// 时间戳转换为日期void convertTimestampToDate(time_t timestamp, string &amp;date)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTm; localtime_r(&amp;timestamp, &amp;dateTm); printf(&quot;%d-%d-%d\\n&quot;, dateTm.tm_year + 1900, dateTm.tm_mon + 1, dateTm.tm_mday); // 2. 将struct tm类型转换为自定义格式化字符串 char dateBuf[16]; strftime(dateBuf, sizeof(dateBuf), &quot;%Y-%m-%d&quot;, &amp;dateTm); date = dateBuf;&#125;// 时间戳转换为日期时间void convertTimestampToDatetime(time_t timestamp, string &amp;date_time)&#123; // 1. 将时间戳转换为struct tm类型: // localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的 struct tm dateTimeTm; localtime_r(&amp;timestamp, &amp;dateTimeTm); // 2. 将struct tm类型转换为自定义格式化字符串 char dateTimeBuf[32]; strftime(dateTimeBuf, sizeof(dateTimeBuf), &quot;%Y-%m-%d %H:%M:%S&quot;, &amp;dateTimeTm); date_time = dateTimeBuf;&#125;int main(int argc, char const *argv[])&#123; printf(&quot;%d\\n&quot;, convertDateToTimestamp(&quot;2022-09-23&quot;)); printf(&quot;%d\\n&quot;, convertDatetimeToTimestamp(&quot;2022-09-23 15:23:59&quot;)); string date; string date_time; convertTimestampToDate(1663917839, date); convertTimestampToDatetime(1663917839, date_time); printf(&quot;%s\\n&quot;, date.c_str()); printf(&quot;%s\\n&quot;, date_time.c_str()); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.sivan.tech/categories/C-C/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.sivan.tech/tags/C-C/"},{"name":"时间","slug":"时间","permalink":"http://www.sivan.tech/tags/%E6%97%B6%E9%97%B4/"}],"author":"yirufeng"},{"title":"consul集群搭建","slug":"consul集群搭建","date":"2021-05-17T08:54:06.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2021/05/17/consul集群搭建/","link":"","permalink":"http://www.sivan.tech/2021/05/17/consul%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","excerpt":"consul环境搭建方法一：docker安装consul集群 自己动手采用docker搭建一个consul集群 123456789101112# 下载最新的consul镜像docker pull consul# 启动我们的第一个consul节点docker run --name consul1 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 2 -ui -bind=0.0.0.0 -client=0.0.0.0# 获取我们第一个启动节点的ip地址：会输出一个ip地址docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; consul1# 启动第二个consul节点docker run --name consul2 -d -p 8501:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 启动第三个consul节点docker run --name consul3 -d -p 8502:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 查看运行的容器docker ps之后访问localhost:8050就可以进入到我们的consul可视化界面 方法二：本机(mac)安装consul： 直接进入consul官网，下载可执行文件，然后解压到$HOME/Library/consul/ 同时将路径加入到我们的系统环境变量~/.bash_profile中12# add consulexport PATH=$PATH:$GOPATH/bin:$HOME/Library/consul 然后刷新我们的配置，此时使用consul执行命令consul members来查看我们docker搭建的consul集群 consul相关命令补充： consul参考资料： 参考1 参考2 docker安装consul集群","text":"consul环境搭建方法一：docker安装consul集群 自己动手采用docker搭建一个consul集群 123456789101112# 下载最新的consul镜像docker pull consul# 启动我们的第一个consul节点docker run --name consul1 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 2 -ui -bind=0.0.0.0 -client=0.0.0.0# 获取我们第一个启动节点的ip地址：会输出一个ip地址docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; consul1# 启动第二个consul节点docker run --name consul2 -d -p 8501:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 启动第三个consul节点docker run --name consul3 -d -p 8502:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 查看运行的容器docker ps之后访问localhost:8050就可以进入到我们的consul可视化界面 方法二：本机(mac)安装consul： 直接进入consul官网，下载可执行文件，然后解压到$HOME/Library/consul/ 同时将路径加入到我们的系统环境变量~/.bash_profile中12# add consulexport PATH=$PATH:$GOPATH/bin:$HOME/Library/consul 然后刷新我们的配置，此时使用consul执行命令consul members来查看我们docker搭建的consul集群 consul相关命令补充： consul参考资料： 参考1 参考2 docker安装consul集群 了解服务发现：在微服务编码中我们服务经常会遇到如下的问题： 客户端连接服务器的时候，IP去掉将无法连接服务器：conn, err := grpc.Dial(&quot;127.0.0.1:10086&quot;, grpc.WithInsecure() 如果先运行客户端再运行服务端，客户端将会报错。 这些问题都需要解决，因此我们需要通过服务发现来解决这些问题 通过服务发现来管理服务： consul的代码并没有开源： 故障检测使得如果有服务挂掉，之后请求的时候将会停止访问我们的服务 服务注册：就是服务主动去consul那里登记，服务发现就是指请求过来之后去consul那里查询对应的服务，此时就是服务发现 consul概念 consul命令参数： consul常用命令 查看集群成员：consul members 查看consul版本：consul version consul leave 用于退出集群 停止Agent： 虚拟机搭建consul集群搭建 环境：3个虚拟机 192.168.110.123 192.168.110.148 192.168.110.124 步骤： 192.168.110.123 主机执行命令：consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -bind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -client 0.0.0.0 192.168.110.148 主机执行命令：consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -bind=192.168.110.148 -ui -rejoin -join 192.168.110.123 ： 访问： 148机器访问： 192.168.110.124主机执行命令： consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir /etc/consuld.d -rejoin -join 192.168.110.123 + 148机器访问： consul 服务注册 测试程序： 在micro中我们不需要手动写consul的配置文件 consul扩展 consul架构图： 如果要跨域（图中的黑色）：通过网络进行连接。 参考 Consul节点创建与集群的搭建（含单机多节点集群）","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"consul","slug":"consul","permalink":"http://www.sivan.tech/tags/consul/"}],"author":"yirufeng"},{"title":"centos7安装docker","slug":"centos7安装docker","date":"2021-03-30T10:14:34.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2021/03/30/centos7安装docker/","link":"","permalink":"http://www.sivan.tech/2021/03/30/centos7%E5%AE%89%E8%A3%85docker/","excerpt":"系统要求：docker支持64位Centos7，并且要求内核版本(查看Linux系统内核版本：uname -r)不低于3.10 卸载旧版本安装docker 卸载旧版本 旧版本的docker称为docker或docker-engine，使用如下命令卸载旧版本1sudo yum remove docker docker-common docker-selinux docker-engine 安装方式一：使用yum安装 1sudo yum install docker-ce如果执行之后返回的是没有可用软件包，此时我们需要安装必要的软件依赖以及更新增加docker-ce yum源12sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo执行完这两条命令之后我们便可以重新执行`sudo yum install docker-ce`进行安装 安装方式二：使用脚本安装 在测试或开发环境中docker官方为了简化安装流程，提供了一套便捷的安装脚本，centos系统上可以使用这套脚本进行安装12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun执行完这个命令之后，系统会自动将一切工作准备好，并把docker ce的Edge版本安装在系统中","text":"系统要求：docker支持64位Centos7，并且要求内核版本(查看Linux系统内核版本：uname -r)不低于3.10 卸载旧版本安装docker 卸载旧版本 旧版本的docker称为docker或docker-engine，使用如下命令卸载旧版本1sudo yum remove docker docker-common docker-selinux docker-engine 安装方式一：使用yum安装 1sudo yum install docker-ce如果执行之后返回的是没有可用软件包，此时我们需要安装必要的软件依赖以及更新增加docker-ce yum源12sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo执行完这两条命令之后我们便可以重新执行`sudo yum install docker-ce`进行安装 安装方式二：使用脚本安装 在测试或开发环境中docker官方为了简化安装流程，提供了一套便捷的安装脚本，centos系统上可以使用这套脚本进行安装12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun执行完这个命令之后，系统会自动将一切工作准备好，并把docker ce的Edge版本安装在系统中 启动docker CE 12sudo systemctl enable dockersudo systemctl start docker启动docker之后可以使用docker info来查看docker的信息 建立docker用户组 默认情况下，docker命令会用Unix Socket与Docker引擎通讯，但是只有root用户与docker组的用户才可以访问Docker引擎的Unix Socket。一般Linux系统上不会直接使用root用户进行操作，因此需要将使用docker的用户加入docker用户组。12sudo groupadd docker #建立 docker 用户s组sudo usermod -aG docker $&#123;USER&#125; #将当前用户加入docker用户组启动docker之后可以使用docker info来查看docker的信息 测试docker是否正确安装 1docker run hello-world #启动一个基于hello-world的镜像的容器 配置docker镜像加速器docker默认从docker hub上拉取镜像，国内会网速偏慢，建议配置镜像加速器 步骤 在/etc/docker/daemon.json文件(如果没有就创建)中写入：这里配置的是自己的阿里云的，建议配置阿里云的（[获取镜像加速器地址](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors）123&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;*(涉密省略)**.mirror.aliyuncs.com&quot;]&#125;重新启动服务生效12sudo systemctl daemon-reloadsudo systemctl restart docker查看一下docker默认下载镜像的地址：执行docker info ，查看Registry Mirrors的内容是否为我们配置的内容。如下图所示： 卸载docker 删除docker安装包 1sudo yum remove docker-ce 删除docker镜像 1sudo rm -rf /var/lib/docker","categories":[{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/categories/docker/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"http://www.sivan.tech/tags/Centos/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/tags/Linux/"}],"author":"yirufeng"},{"title":"两个全排列的题目","slug":"两个全排列的题目","date":"2020-11-28T20:28:09.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/11/28/两个全排列的题目/","link":"","permalink":"http://www.sivan.tech/2020/11/28/%E4%B8%A4%E4%B8%AA%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E9%A2%98%E7%9B%AE/","excerpt":"第一道题","text":"第一道题 思路每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，我们从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，之后进行下一层的递归最后递归回来之后，我们再交换回去 代码 12345678910111213141516171819202122232425262728293031323334353637//✅//核心：如何做到每次从后面的选择，并且不会重复呢？如果后面选择某个元素，我们就把该元素交换到我们已经选择完的下一个元素//index表示下次从nums中的哪个位置元素开始，因为之前的都已经选好了func backtrack(ret *[][]int, path []int, index int, nums []int) &#123; if len(path) == len(nums) &#123; //将当前路径加入到结果中 temp := make([]int, len(path)) copy(temp, path) *ret = append(*ret, temp) return &#125; //开始进入选择 for i := index; i &lt; len(nums); i++ &#123; //利用交换，让我们每次选择的都放置到上次选择的后面那个相邻元素 nums[i], nums[index] = nums[index], nums[i] //下次我们将index位置的元素加入路径 path = append(path, nums[index]) //进入下一层 backtrack(ret, path, index+1, nums) //从路径中撤销 path = path[:len(path)-1] //撤销交换 nums[i], nums[index] = nums[index], nums[i] &#125;&#125;func permute(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; var ret [][]int backtrack(&amp;ret, []int&#123;&#125;, 0, nums) return ret&#125; 第二道题 note info 核心：如何避免重复出现。思路：我们使用一个map或者set来统计index位置，我们已经交换过的元素，如果下次要交换的元素与我们之前交换过的元素的元素值相同则跳过，因此我们可以使用map或者set来统计。但是要注意位置，每次递归进来的时候我们都要重新建立针对当前index位置的一个统计容器 思路每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，如果放置的元素与我们之前放置过的元素不重复，那么我们将从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，之后进行下一层的递归最后递归回来之后，我们再交换回去 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//✅func permuteUnique(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; var ret [][]int backtrack(nums, &amp;ret, 0, []int&#123;&#125;) return ret&#125;func backtrack(nums []int, ret *[][]int, index int, path []int) &#123; if len(nums) == len(path) &#123; temp := make([]int, len(nums)) copy(temp, path) *ret = append(*ret, temp) return &#125; visited := make(map[int]bool) for i := index; i &lt; len(nums); i++ &#123; //如果没有被访问过 if !visited[nums[i]] &#123; nums[i], nums[index] = nums[index], nums[i] //加入路径以及visited中 path = append(path, nums[index]) visited[nums[index]] = true //进入到下一层 backtrack(nums, ret, index+1, path) //撤销加入路径以及撤销加入visited中 path = path[:len(path)-1] //❌ //下面这一行代码是不需要的，因为当前可选的数字如果选了加入到visited下次我们就不可以再选了，所以不可以再撤销了 //delete(visited, nums[index]) //撤销交换 nums[i], nums[index] = nums[index], nums[i] &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"算法","slug":"LeetCode/算法","permalink":"http://www.sivan.tech/categories/LeetCode/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"}],"author":"yirufeng"},{"title":"二叉树的序列化与反序列化","slug":"二叉树的序列化与反序列化","date":"2020-11-18T16:25:33.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/11/18/二叉树的序列化与反序列化/","link":"","permalink":"http://www.sivan.tech/2020/11/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"前言序列化：二叉树被记录成文件的过程叫做序列化 反序列化：通过文件内容重建原来二叉树的过程叫做反序列化","text":"前言序列化：二叉树被记录成文件的过程叫做序列化 反序列化：通过文件内容重建原来二叉树的过程叫做反序列化 第一种方式：先序遍历 先序遍历进行序列化和反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125; 第二种方式：层次遍历自己写的层次遍历序列化 层次遍历进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//方法二：使用层次遍历进行序列化和反序列化func LevelOrderSerialize(root *TreeNode) string &#123; //首先如果根节点为空，我们直接返回一个空字符串即可 if root == nil &#123; return &quot;#!&quot; &#125; var ret string queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; //首先弹出一个节点 node := queue[0] queue = queue[1:] //如果弹出的节点不为空，我们直接将值转换为字符串并加入其中 if node != nil &#123; ret += strconv.Itoa(node.Val) + &quot;!&quot; &#125; else &#123; ret += &quot;#!&quot; //这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码 continue &#125; queue = append(queue, node.Left) queue = append(queue, node.Right) &#125; return ret&#125;func LevelOrderDeserialize(str string) *TreeNode &#123; strs := strings.Split(str, &quot;!&quot;) root := LevelOrderReconstruct(strs) return root&#125;//根据层次遍历重建二叉树func LevelOrderReconstruct(strs []string) *TreeNode &#123; var head *TreeNode //一进来首先建立根节点 if strs[0] == &quot;#&quot; &#123; return nil &#125; else &#123; val, _ := strconv.Atoi(strs[0]) head = &amp;TreeNode&#123; Val: val, &#125; &#125; //用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点 //因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点 index := 1 //使用一个队列将我们后面需要建立子树的非空节点加入进来， queue := []*TreeNode&#123;head&#125; for len(queue) != 0 &#123; //说明当前开始建立cur的左右子树 cur := queue[0] queue = queue[1:] //建立左子树 if strs[index] == &quot;#&quot; &#123; cur.Left = nil &#125; else &#123; val, _ := strconv.Atoi(strs[index]) cur.Left = &amp;TreeNode&#123; Val: val, &#125; queue = append(queue, cur.Left) &#125; index++ //建立右子树 if strs[index] == &quot;#&quot; &#123; cur.Right = nil &#125; else &#123; val, _ := strconv.Atoi(strs[index]) cur.Right = &amp;TreeNode&#123; Val: val, &#125; queue = append(queue, cur.Right) &#125; index++ &#125; return head&#125; 参考左神代码：对层次遍历进行序列化和反序列化的改进 加入了一个函数generateNodeFromString避免代码臃肿 层次遍历进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//对方法二的改进func LevelOrderSerialize(root *TreeNode) string &#123; //首先如果根节点为空，我们直接返回一个空字符串即可 if root == nil &#123; return &quot;#!&quot; &#125; var ret string queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; //首先弹出一个节点 node := queue[0] queue = queue[1:] //如果弹出的节点不为空，我们直接将值转换为字符串并加入其中 if node != nil &#123; ret += strconv.Itoa(node.Val) + &quot;!&quot; &#125; else &#123; ret += &quot;#!&quot; //这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码 continue &#125; queue = append(queue, node.Left) queue = append(queue, node.Right) &#125; return ret&#125;func LevelOrderDeserialize(str string) *TreeNode &#123; strs := strings.Split(str, &quot;!&quot;) root := LevelOrderReconstruct(strs) return root&#125;//根据层次遍历重建二叉树func LevelOrderReconstruct(strs []string) *TreeNode &#123; //一进来首先建立根节点 head := generateNodeFromString(strs[0]) //这里要注意判断一下head是否为空 //注意点：判断head是否为空，如果为空就推出，否则后面会报错的 if head == nil &#123; return nil &#125; //用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点 //因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点 index := 1 //使用一个队列将我们后面需要建立子树的非空节点加入进来， queue := []*TreeNode&#123;head&#125; for len(queue) != 0 &#123; //说明当前开始建立cur的左右子树 cur := queue[0] queue = queue[1:] //建立左子树 cur.Left = generateNodeFromString(strs[index]) index++ //建立右子树 cur.Right = generateNodeFromString(strs[index]) index++ //如果左子树不为空，加入到队列中 if cur.Left != nil &#123; queue = append(queue, cur.Left) &#125; //如果右子树不为空，加入到队列中 if cur.Right != nil &#123; queue = append(queue, cur.Right) &#125; &#125; return head&#125;func generateNodeFromString(val string) *TreeNode &#123; if val == &quot;#&quot; &#123; return nil &#125; temp, _ := strconv.Atoi(val) return &amp;TreeNode&#123; Val: temp, &#125;&#125; 可能出现的问题递归函数传入切片作为参数造成切片修改后递归回来又还原","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"},{"name":"二叉树","slug":"算法/面试/二叉树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"}],"author":"yirufeng"},{"title":"Golang中刷题关于切片的一些坑","slug":"golang中刷题关于切片的一些坑","date":"2020-11-18T09:58:06.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/11/18/golang中刷题关于切片的一些坑/","link":"","permalink":"http://www.sivan.tech/2020/11/18/golang%E4%B8%AD%E5%88%B7%E9%A2%98%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"问题1问题描述：递归的过程中，传递了一个切片作为参数，每次我们都需要对切片切取首元素，之后递归回来的时候发现切片中的元素还是没有切取首元素，是一个很严重的逻辑错误。 问题解决：我们递归函数使用切片作为参数的时候，我们直接传入切片的地址。因为切片每次删除元素，地址也会改变。当切片增加元素引起扩容，地址也会发生改变，而如果只传入切片我们只是引用最开始的时候的切片的地址，因此会发现切片没有任何改变。 例如我们自己写的二叉树序列化和反序列化代码：在最开始只是传递一个切片，但是后来传递切片的地址进去发现代码逻辑正常运行。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125;","text":"问题1问题描述：递归的过程中，传递了一个切片作为参数，每次我们都需要对切片切取首元素，之后递归回来的时候发现切片中的元素还是没有切取首元素，是一个很严重的逻辑错误。 问题解决：我们递归函数使用切片作为参数的时候，我们直接传入切片的地址。因为切片每次删除元素，地址也会改变。当切片增加元素引起扩容，地址也会发生改变，而如果只传入切片我们只是引用最开始的时候的切片的地址，因此会发现切片没有任何改变。 例如我们自己写的二叉树序列化和反序列化代码：在最开始只是传递一个切片，但是后来传递切片的地址进去发现代码逻辑正常运行。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125;","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://www.sivan.tech/tags/%E5%88%B7%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"}],"author":"yirufeng"},{"title":"二叉树的三种遍历方式","slug":"二叉树的三种遍历方式","date":"2020-11-17T20:30:26.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/11/17/二叉树的三种遍历方式/","link":"","permalink":"http://www.sivan.tech/2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","excerpt":"基于递归的遍历","text":"基于递归的遍历 先序遍历 先序遍历方式1 123456789101112131415161718//✅代码func PreorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val) if root.Left != nil &#123; ret = append(ret, PreorderTraverse(root.Left)...) &#125; if root.Right != nil &#123; ret = append(ret, PreorderTraverse(root.Right)...) &#125; return ret&#125; 先序遍历方式2 123456789101112func PreorderTraverseII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val) ret = append(ret, PreorderTraverse(root.Left)...) ret = append(ret, PreorderTraverse(root.Right)...) return ret&#125; 先序遍历错误方式 错误方式12345678910func PreorderTraverseIII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val, PreorderTraverseIII(root.Left)..., PreorderTraverseIII(root.Right)...) return ret&#125; 中序遍历 中序遍历 1234567891011func InorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, InorderTraverse(root.Left)...) ret = append(ret, root.Val) ret = append(ret, InorderTraverse(root.Right)...) return ret&#125; 后序遍历 后序遍历 123456789101112func PostorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, PostorderTraverse(root.Left)...) ret = append(ret, PostorderTraverse(root.Right)...) ret = append(ret, root.Val) return ret&#125; 基于非递归的遍历先序遍历 申请一个新的栈，记为stack，然后将头结点压入到stack中 从stack中弹出栈顶结点，记为cur，然后打印cur结点的值，再将cur结点的右孩子（不为空）压入到栈中，最后将左孩子（不为空）压入到stack中 不断重复步骤2，直到stack为空，全部过程结束 非递归实现二叉树的先序遍历 123456789101112131415161718192021222324252627282930//✅//思路：使用栈来求解，初始化的时候若根不为空，则将根加入到栈中，//之后，每次遍历到一个节点将值加入到结果中并弹出，然后将右子树加入到栈中，之后将左子树加入到栈中func PreorderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; for len(stack) != 0 &#123; //首先从栈中弹出一个节点 node := stack[len(stack)-1] stack = stack[:len(stack)-1] //将当前节点的值加入到我们要返回的结果中 ret = append(ret, node.Val) //将当前节点的右节点加入到栈中 if node.Right != nil &#123; stack = append(stack, node.Right) &#125; //将当前节点的左节点加入到栈中 if node.Left != nil &#123; stack = append(stack, node.Left) &#125; &#125; return ret&#125; 中序遍历 申请一个新栈，记为stack。初始时，令变量cur = head 先把cur节点压入栈中，对以cur节点为头节点的整颗子树来说，依次把左边界压入到栈中，即不停地令cur = cur.Left，然后重复步骤3 不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点，记为node，打印node的值，并且让cur = node.right，然后继续重复步骤2。 当stack为空且cur为空，整个过程停止。 非递归实现二叉树的中序遍历 123456789101112131415161718192021222324252627282930//✅func InorderTraverseNoRecursion(root *TreeNode) []int &#123; //如果为空，直接返回 if root == nil &#123; return nil &#125; var ret []int var stack []*TreeNode cur := root for cur != nil || len(stack) != 0 &#123; if cur != nil &#123; //说明当前节点是第一次遍历，直接加入到栈中 stack = append(stack, cur) //之后移动到该节点的左子树节点 cur = cur.Left &#125; else &#123; //首先从栈中弹出一个节点 cur = stack[len(stack)-1] stack = stack[:len(stack)-1] //将当前节点的值加入到结果中 ret = append(ret, cur.Val) //之后移动到当前节点的右节点 cur = cur.Right &#125; &#125; return ret&#125; 后序遍历第一种方式：先介绍用两个栈实现后序遍历的过程，具体过程如下： 1．申请一个栈，记为s1，然后将头节点head压入s1中。 2．从s1中弹出的节点记为cur，然后依次将cur的左孩子和右孩子压入s1中。 3．在整个过程中，每一个从s1中弹出的节点都放进s2中。 4．不断重复步骤2和步骤3，直到s1为空，过程停止。 5．从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。” 通过如上过程我们知道，每棵子树的头节点都最先从s1中弹出，然后把该节点的孩子节点按照先左再右的顺序压入s1，那么从s1弹出的顺序就是先右再左，所以从s1中弹出的顺序就是中、右、左。然后，s2重新收集的过程就是把s1的弹出顺序逆序，所以s2从栈顶到栈底的顺序就变成了左、右、中。 非递归实现二叉树的后序遍历方式1 12345678910111213141516171819202122232425262728293031323334353637383940414243//✅//方法一：使用两个栈实现二叉树的非递归后序遍历func PostorderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int var stack2 []*TreeNode //首先我们将root加入到stack1中 stack1 := []*TreeNode&#123;root&#125; //如果stack1不为空 for len(stack1) != 0 &#123; cur := stack1[len(stack1)-1] //将当前节点从栈1移除并且将当前节点加入到栈2 stack1 = stack1[:len(stack1)-1] //将当前节点的左右子节点分别加入到栈1 //注意点1：这里有可能左右子节点有可能为空 if cur.Left != nil &#123; stack1 = append(stack1, cur.Left) &#125; if cur.Right != nil &#123; stack1 = append(stack1, cur.Right) &#125; //之后将当前节点加入到栈2中 stack2 = append(stack2, cur) &#125; //最后我们从stack2弹出的顺序就是我们后序遍历得到的结果 for len(stack2) != 0 &#123; node := stack2[len(stack2)-1] stack2 = stack2[:len(stack2)-1] ret = append(ret, node.Val) &#125; return ret&#125; 第二种方式：最后介绍只用一个栈实现后序遍历的过程，具体过程如下： 1．申请一个栈，记为stack，将头节点压入stack，同时设置两个变量h和c。在整个流程中，h代表最近一次弹出并打印的节点，c代表” 摘录来自: 左程云. “程序员代码面试指南:IT名企算法与数据结构题目最优解。” Apple Books. “stack的栈顶节点，初始时h为头节点，c为null。 2．每次令c等于当前stack的栈顶节点，但是不从stack中弹出，此时分以下三种情况。 ①：如果c的左孩子不为null，并且h不等于c的左孩子，也不等于c的右孩子，则把c的左孩子压入stack中。具体解释一下这么做的原因，首先h的意义是最近一次弹出并打印的节点，所以如果h等于c的左孩子或者右孩子，说明c的左子树与右子树已经打印完毕，此时不应该再将c的左孩子放入stack中。否则，说明左子树还没处理过，那么此时将c的左孩子压入stack中。 ②：如果条件①不成立，并且c的右孩子不为null，h不等于c的右孩子，则把c的右孩子压入stack中。含义是如果h等于c的右孩子，说明c的右子树已经打印完毕，此时不应该再将c的右孩子放入stack中。否则，说明右子树还没处理过，此时将c的右孩子压入stack中。 ③：如果条件①和条件②都不成立，说明c的左子树和右子树都已经打印完毕，那么从stack中弹出c并打印，然后令h=c。 3．一直重复步骤2，直到stack为空，过程停止。” 非递归实现二叉树的后序遍历方式2： 12345678910111213141516171819202122232425262728293031323334//方法二：只使用一个栈实现二叉树的非递归后序遍历//✅//思路：使用一个栈和两个变量，h代表上次访问并删除的节点，c代表当前节点func PostorderTraverseNoRecursionII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; //初始化的时候h置为root，将c置为nil h := root var c *TreeNode //如果栈不为空 for len(stack) != 0 &#123; c = stack[len(stack)-1] //如果当前节点的左子树不为空，并且左右子树都不等于h，说明左子树没有遍历过，将左节点加入栈中 if c.Left != nil &amp;&amp; h != c.Left &amp;&amp; h != c.Right &#123; //也就是第一次遍历该节点的时候 stack = append(stack, c.Left) &#125; else if c.Right != nil &amp;&amp; c.Right != h &#123; //如果当前节点的右子树不为空，且不等于h，说明没有遍历过，则将右节点加入到栈中，也就是第二次遍历该节点的时候 stack = append(stack, c.Right) &#125; else &#123; //否则，弹出节点，并加入到结果中，也就是第三次遍历该节点的时候 node := stack[len(stack)-1] stack = stack[:len(stack)-1] ret = append(ret, node.Val) //并且将上一次访问并且打印过的节点重置为node h = node &#125; &#125; return ret&#125; 【推荐】第三种方式： 后序遍历是按照左-&gt;右-&gt;根的顺序遍历，我们可以按照根-&gt;右-&gt;左的顺序遍历，然后将我们的结果反转即可。 非递归实现二叉树的后序遍历方式3： 1234567891011121314151617181920212223242526272829func PostOrderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; //按照根右左的顺序遍历之后反转我们的结果 for len(stack) != 0 &#123; cur := stack[len(stack)-1] stack = stack[:len(stack)-1] ret = append(ret, cur.Val) if cur.Left != nil &#123; //加入左 stack = append(stack, cur.Left) &#125; if cur.Right != nil &#123; //加入右 stack = append(stack, cur.Right) &#125; &#125; //反转我们的ret for i := 0; i &lt; len(ret)&gt;&gt;1; i++ &#123; ret[i], ret[len(ret)-1-i] = ret[len(ret)-1-i], ret[i] &#125; fmt.Println(ret) return ret&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.sivan.tech/tags/DP/"},{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.sivan.tech/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"yirufeng"},{"title":"BFPRT算法-Golang","slug":"BFPRT算法-Golang","date":"2020-10-12T11:02:42.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/10/12/BFPRT算法-Golang/","link":"","permalink":"http://www.sivan.tech/2020/10/12/BFPRT%E7%AE%97%E6%B3%95-Golang/","excerpt":"这个BFPRT算法找逻辑Bug找了两天 注意点： 在找中位数的时候对传入的数组进行排序，这里使用直接插入排序，因为元素个数最多为5，插排常数项极低 注意：这里不是nums[j] &gt; nums[i]而是for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j--，因为后面会对nums[i]造成修改 找中位数数组的中位数medianOfMedians返回的是最终的中位数的值，我们使用这个值进行Partition，自己这里还一直将其当做返回的索引用，导致越界 BFPRT函数调用自己的时候，参数一定要对应，自己在写的时候直接将k传入了start","text":"这个BFPRT算法找逻辑Bug找了两天 注意点： 在找中位数的时候对传入的数组进行排序，这里使用直接插入排序，因为元素个数最多为5，插排常数项极低 注意：这里不是nums[j] &gt; nums[i]而是for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j--，因为后面会对nums[i]造成修改 找中位数数组的中位数medianOfMedians返回的是最终的中位数的值，我们使用这个值进行Partition，自己这里还一直将其当做返回的索引用，导致越界 BFPRT函数调用自己的时候，参数一定要对应，自己在写的时候直接将k传入了start 具体流程：其实BFPRT算法与我们之前的快排唯一的区别就在于选择划分元素，之后的partition过程与我们的荷兰国旗划分是一样的。 应用场景：无序数组中找到第K小或第K大的数，也可以找到前K大或前K小的数，因为快速排序的partition长期期望时间复杂度为O(N)，而BFPRT算法的时间复杂度稳定在O(N) 具体流程 将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，时间复杂度：O(1)组内排序，并将所有数组的中位数组成一个新数组，时间复杂度：O(N)获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)，时间复杂度：O(N)之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归，时间复杂度：O(7/10 * n) 如何求前k大或者前k小呢？这里我们的BFPRT算法返回的是第k小的数，但是如果我们想要返回前k小或者前k大的数，我们需要再对数据进行一次遍历，找到比该数小的，如果不够，再加入该数，直到找到k个为止进行返回，同理前k大的数可以转换为长度-k小的，求出之后按照上述思路求得我们最终的前k大的数即可 具体实现 以BFPRT获取第K小的元素为例，例如：直接调用BFPRT(nums, 0, len(nums)-1, 1)找的就是第1小的数也就是最小的数 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;math&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/12 9:08 上午 * @Desc: BFPRT算法步骤：1. 将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，2. 组内排序，并将所有数组的中位数组成一个新数组3. 获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)4. 之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归*/func min(a, b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125;//采用类似于荷兰国旗问题的划分思路，划分为小于等于与大于三个区间func partition(nums []int, start int, end int, target int) (int, int) &#123; //l, r分别表示小于target已经有序的区域和大于target已经有序的区域 l, r := start-1, end+1 cur := start for cur &lt; r &#123; if nums[cur] &gt; target &#123; nums[r-1], nums[cur] = nums[cur], nums[r-1] r-- &#125; else if nums[cur] &lt; target &#123; nums[cur], nums[l+1] = nums[l+1], nums[cur] l++ cur++ &#125; else if nums[cur] == target &#123; cur++ &#125; &#125; return l + 1, r - 1&#125;//获取传入数组nums在start-&gt;end之间的中位数，包括两个边界func getMedianOfNums(nums []int, start int, end int) int &#123; //对nums[start:end]进行直接插入排序 var temp, j int for i := start + 1; i &lt;= end; i++ &#123; temp = nums[i] //注意点1：nums[j] &gt; temp for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j-- &#123; nums[j+1] = nums[j] &#125; nums[j+1] = temp &#125; return nums[start+(end-start)&gt;&gt;1]&#125;//选取中位数数组的中位数并进行返回func medianOfMedians(nums []int, start int, end int) int &#123; //首先将传入的数组有效区间内的元素每5个划分为1组，不足5个的不划分 //注意点2：是float64(end - start + 1)不是float64(len(nums)) medianNums := make([]int, int(math.Ceil(float64(end-start+1)/5.0))) //找到每个数组的中位数，添加到我们的中位数数组中 for i := 0; i &lt; len(medianNums); i++ &#123; val := getMedianOfNums(nums, start+i*5, min(start+i*5+4, end)) medianNums[i] = val &#125; //返回中位数数组的中位数 return getMedianOfNums(medianNums, 0, len(medianNums)-1)&#125;//最后一个参数k表示要第k小的数，所以我们返回第k小的数，其中k从1开始func BFPRT(nums []int, start int, end int, k int) int &#123; //递归结束条件 if start == end &#123; return nums[start] &#125; //获取nums每5个一组后划分的中位数数组的中位数 //之后根据pivot进行partition //注意点3：这里是medianOfMedians(nums, start, end)而不是nums[medianOfMedians(nums, start, end)] //因为我们medianOfMedians(nums, start, end)返回的就是划分值 l, r := partition(nums, start, end, medianOfMedians(nums, start, end)) //判断k是否在划分后的两个索引 if k &gt;= l &amp;&amp; k &lt;= r &#123; return nums[l] &#125; else if k &lt; l &#123; return BFPRT(nums, start, l-1, k) &#125; else &#123; return BFPRT(nums, r+1, end, k) &#125;&#125; 总结：按照沈剑老师的总结： TopK，不难；其思路优化过程，不简单： 全局排序，O(n*lg(n)) 局部排序，只排序TopK个数，O(n*k) 堆，TopK个数也不排序了，O(n*lg(k)) 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n)) 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n) TopK的另一个解法：随机选择+partition 本文讲解的bfprt，时间复杂度长期稳定在O(N) References 参考","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"BFPRT","slug":"算法/BFPRT","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/BFPRT/"}],"tags":[{"name":"BFPRT","slug":"BFPRT","permalink":"http://www.sivan.tech/tags/BFPRT/"},{"name":"topK","slug":"topK","permalink":"http://www.sivan.tech/tags/topK/"},{"name":"找第几大或第几小","slug":"找第几大或第几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E7%AC%AC%E5%87%A0%E5%A4%A7%E6%88%96%E7%AC%AC%E5%87%A0%E5%B0%8F/"},{"name":"找前几大或前几小","slug":"找前几大或前几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E5%89%8D%E5%87%A0%E5%A4%A7%E6%88%96%E5%89%8D%E5%87%A0%E5%B0%8F/"}],"author":"yirufeng"},{"title":"不基于比较的排序找到数组排序后的最大差值","slug":"不基于找到数组排序后的最大差值","date":"2020-09-26T20:38:00.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/09/26/不基于找到数组排序后的最大差值/","link":"","permalink":"http://www.sivan.tech/2020/09/26/%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","excerpt":"题目描述给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 注意不基于比较哦 思路 思路：桶排序 假设数组长度为n，准备n+1个桶遍历该数组，将最小值放入到第1个位置，将最大值放入到最后一个位置将剩下的数等分成等分成n-1份依次放入剩下对应范围的桶中，最后这n+1个桶中至少有一个空桶，说明桶内的数值差不是最大差值，我们去桶间找最大差值对于每个桶，我们都保存了每个桶的最小值和最大值，从第2个桶开始，每次计算当前桶的最小值与前一个桶(要有元素)的最大值的差，过程中我们动态更新最大差值","text":"题目描述给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 注意不基于比较哦 思路 思路：桶排序 假设数组长度为n，准备n+1个桶遍历该数组，将最小值放入到第1个位置，将最大值放入到最后一个位置将剩下的数等分成等分成n-1份依次放入剩下对应范围的桶中，最后这n+1个桶中至少有一个空桶，说明桶内的数值差不是最大差值，我们去桶间找最大差值对于每个桶，我们都保存了每个桶的最小值和最大值，从第2个桶开始，每次计算当前桶的最小值与前一个桶(要有元素)的最大值的差，过程中我们动态更新最大差值 具体编码 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func GetMaxDiff(nums []int) int &#123; maxNum := make([]int, len(nums)+1) minNum := make([]int, len(nums)+1) hasNum := make([]bool, len(nums)+1) //用来标记桶是否有值 min, max := math.MaxInt64, math.MinInt64 //整个数组的最小值和最大值 maxDiff := math.MinInt64 //最大差值 //找数组的最大值与最小值 for _, v := range nums &#123; if v &gt; max &#123; max = v &#125; if min &gt; v &#123; min = v &#125; &#125; //第一个位置放最小值，第2个位置放最大值 hasNum[0], hasNum[len(nums)] = true, true //将最大值与最小值之间等分成n(n为数组的长度)-1份，依次遍历属于哪个范围就加入哪个桶 diff := float64(max-min) / float64(len(nums)-1) for _, v := range nums &#123; indexBucket := int(math.Ceil(float64(v-min) / diff)) //如果当前桶没有值 if !hasNum[indexBucket] &#123; maxNum[indexBucket] = v minNum[indexBucket] = v &#125; else &#123; //当前桶有值且当前桶的最大值小于当前元素 则更新 if maxNum[indexBucket] &lt; v &#123; maxNum[indexBucket] = v &#125; if minNum[indexBucket] &gt; v &#123; minNum[indexBucket] = v &#125; &#125; //最后将当前桶置为true，说明已放入元素 hasNum[indexBucket] = true &#125; //这里要注意：不是两个相邻的桶之间进行比较 //遍历桶，找当前桶与上一个存放元素的桶的最大差值并返回 lastMax := min //存放上一个最大 for i := 1; i &lt; len(nums); i++ &#123; if hasNum[i] &#123; if maxDiff &lt; minNum[i]-lastMax &#123; maxDiff = minNum[i] - lastMax &#125; lastMax = maxNum[i] &#125; &#125; return maxDiff&#125;func main() &#123; nums := utils.RandArrayRange(10, 10, 99) fmt.Println(nums) fmt.Println(GetMaxDiff(nums))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"桶排序","slug":"桶排序","permalink":"http://www.sivan.tech/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"堆排序","slug":"堆排序","date":"2020-09-24T21:07:00.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"2020/09/24/堆排序/","link":"","permalink":"http://www.sivan.tech/2020/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"堆排序基本知识 基本介绍 堆是一个完全二叉树，因此我们可以利用节点的特性去使用一个数组模拟一颗完全二叉树：下标为i的节点的左子节点的下标为i*2+1, 右子节点的下标为i*2+2下标为i的节点的父节点的下标为(i-1)/2 建立堆的时间复杂度：O(log1) + O(log2) + … + O(logN) 近似于 O(N)，因此建立堆的时间复杂度为O(N) 堆有大根堆以及小根堆，没有规定堆中左子树的根必须大于(或小于)右子树的根。 堆排序的两个基本步骤：(具体说明看代码注释) 建堆，循环将数组中的每个数加入堆中（每次都需要heapInsert）不断从堆的最后一个元素交换到堆的头部，然后将堆的长度减小1，再调整堆，每次都需要heapify","text":"堆排序基本知识 基本介绍 堆是一个完全二叉树，因此我们可以利用节点的特性去使用一个数组模拟一颗完全二叉树：下标为i的节点的左子节点的下标为i*2+1, 右子节点的下标为i*2+2下标为i的节点的父节点的下标为(i-1)/2 建立堆的时间复杂度：O(log1) + O(log2) + … + O(logN) 近似于 O(N)，因此建立堆的时间复杂度为O(N) 堆有大根堆以及小根堆，没有规定堆中左子树的根必须大于(或小于)右子树的根。 堆排序的两个基本步骤：(具体说明看代码注释) 建堆，循环将数组中的每个数加入堆中（每次都需要heapInsert）不断从堆的最后一个元素交换到堆的头部，然后将堆的长度减小1，再调整堆，每次都需要heapify 具体实现 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384func HeapSort(nums []int) []int &#123; heapSort(nums) return nums&#125;func heapSort(nums []int) &#123; if nums == nil || len(nums) &lt; 2 &#123; return &#125; //建立堆的过程 for i := 0; i &lt; len(nums); i++ &#123; heapInsert(nums, i) &#125; log.Println(&quot;建堆完成---------------&gt;&quot;, nums) heapSize := len(nums) //之后不断吐出元素 for heapSize &gt; 0 &#123; nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] heapSize-- heapify(nums, heapSize, 0) &#125;&#125;//用于新加入一个元素之后，向上调整堆//第2个参数表示新加入的元素的下标//这个过程的时间复杂度为O(N) = O(log1 + log2 + ... + logN) 近似等于 O(N)func heapInsert(nums []int, index int) &#123; //这里左神说了不用加循环结束条件，因为最终的结束条件就是index为0的时候 //因为-1/2也为0 for nums[(index-1)/2] &lt; nums[index] &#123; nums[index], nums[(index-1)&gt;&gt;1] = nums[(index-1)&gt;&gt;1], nums[index] index = (index - 1) &gt;&gt; 1 &#125;&#125;//左老师的写法////func heapify(nums []int, heapSize int, index int) &#123;//// left := 2*index + 1// for left &lt; heapSize &#123;// larger := left// //首先找到左右孩子中最大的// if left+1 &lt; heapSize &amp;&amp; nums[left] &lt; nums[left+1] &#123;// larger++// &#125;//// //这里要注意一下，如果使用一个变量这里可能会溢出，这里我们使用的larger经过了前面的验证// if nums[larger] &lt;= nums[index] &#123;// break// &#125;//// nums[index], nums[larger] = nums[larger], nums[index]// index = larger// left = index*2 + 1// &#125;//&#125;//用于将堆顶的元素和堆中最后一个元素交换之后，向下调整堆//第2个参数为堆的实际大小，因为nums是存放一个数组，//第3个参数表示该位置元素变动，导致该元素可能要往下沉//真正的堆是从0-&gt;heapSize-1func heapify(nums []int, heapSize int, index int) &#123; //注意循环条件 for i := index; i*2+1 &lt; heapSize; &#123; left := 2*i + 1 //如果有右并且右比左大 if left+1 &lt; heapSize &amp;&amp; nums[left+1] &gt; nums[left] &#123; left++ &#125; //与左右中较大的比较 if nums[i] &gt;= nums[left] &#123; break &#125; nums[i], nums[left] = nums[left], nums[i] i = left &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.sivan.tech/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"面试问题之Top K系列","slug":"面试问题之Top K系列","date":"2020-09-12T09:10:00.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"2020/09/12/面试问题之Top K系列/","link":"","permalink":"http://www.sivan.tech/2020/09/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8BTop%20K%E7%B3%BB%E5%88%97/","excerpt":"思路整理：","text":"思路整理： 如图所示 几种方法讲解 以剑指offer40题为例，求最小的k个数字 方法一： 思路：直接用最快的排序方法排好序后取前k个或者后k个元素即可 时间复杂度：O(n * logn)空间复杂度：O(1) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func getLeastNumbers(arr []int, k int) []int &#123; return QuickSort(arr)[:k]&#125;func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int //优化1：尾递归优化 for low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) low = pivotkey + 1 &#125;&#125;func partition(nums []int, low int, high int) int &#123; //优化2：使用随机数选择划分枢轴 //设置随机数种子 rand.Seed(time.Now().UnixNano()) //选择[0,n) //rand.Intn(n) //选择划分元素 dummyIndex := rand.Intn(high-low+1) + low //将随机选择的元素放置到low位置上，以后便于在高处找到比划分元素小的时候我们可以直接让high赋值给low swap(nums, low, dummyIndex) dummyVal := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummyVal &lt;= nums[high] &#123; high-- &#125; //优化3：我们使用替换而不是交换 //高处找到小的直接赋值给low nums[low] = nums[high] for low &lt; high &amp;&amp; dummyVal &gt;= nums[low] &#123; low++ &#125; //低处找到大的直接赋值给high nums[high] = nums[low] &#125; //最后low == high nums[low] = dummyVal return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125; 方法二： 思路：冒泡排序每次都会将1个元素放置到最终位置上，我们可以冒泡k趟 时间复杂度：O(k * n)空间复杂度：O(1) 代码 123456789101112func getLeastNumbers(arr []int, k int) []int &#123; //需要冒泡k次 for i := 1; i &lt;= k; i++ &#123; //每次从倒数第2个元素开始一直到前面的第i-1个元素，例如第1趟是到第0个(因为每次是和后面的元素进行比较) for j := len(arr) - 2; j &gt;= i-1; j-- &#123; if arr[j] &gt; arr[j+1] &#123; arr[j+1], arr[j] = arr[j], arr[j+1] &#125; &#125; &#125; return arr[:k]&#125; 方法三： 思路：构建一个容量为k的堆，不断遍历数据，插入后进行调整，最后依次返回组合成我们要的结果 适合处理海量数据 时间复杂度：O(n*logk)空间复杂度：O(K) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type IntHeap []int//Heap Interface//type Interface interface &#123;// sort.Interface// Push(x interface&#123;&#125;) // 向末尾添加元素// Pop() interface&#123;&#125; // 从末尾删除元素//&#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;// Sort Interface//type Interface interface &#123;// // Len方法返回集合中的元素个数// Len() int// // Less方法报告索引i的元素是否比索引j的元素小// Less(i, j int) bool// // Swap方法交换索引i和j的两个元素// Swap(i, j int)//&#125;func (h IntHeap) Len() int &#123; return len(h)&#125;//表明是一个小顶堆func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j]&#125;func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func getLeastNumbers(arr []int, k int) []int &#123; h := &amp;IntHeap&#123;&#125; for _, val := range arr &#123; heap.Push(h, val) &#125; ret := []int&#123;&#125; for i := 0; i &lt; k; i++ &#123; ret = append(ret, heap.Pop(h).(int)) &#125; return ret&#125; 方法四： 思路：随机选择，通过减治的思想利用快速排序中的partition方法可以对我们要求的那个划分轴进行快速选择， 算法导论中提过，我们有成熟的时间复杂度为O(n)的算法来获取任意第k大的数，也就是基于partition的随机选择方法 时间复杂度：O(N)空间复杂度：O(1) 会对传入的切片进行修改 代码 1234567891011121314151617181920212223242526272829303132333435363738394041func partition(arr []int, start int, end int) int &#123; rand.Seed(time.Now().UnixNano()) index := rand.Intn(end-start+1) + start val := arr[index] arr[index], arr[start] = arr[start], arr[index] for start &lt; end &#123; for start &lt; end &amp;&amp; val &lt;= arr[end] &#123; end-- &#125; arr[start] = arr[end] for start &lt; end &amp;&amp; val &gt;= arr[start] &#123; start++ &#125; arr[end] = arr[start] &#125; arr[start] = val return start&#125;func getLeastNumbers(arr []int, k int) []int &#123; //特殊情况 if len(arr) == 0 || k &lt;= 0 &#123; return nil &#125; else if k &gt;= len(arr) &#123; return arr &#125; index := partition(arr, 0, len(arr)-1) for index != k-1 &#123; if index &gt; k-1 &#123; //说明在左边 index = partition(arr, 0, index-1) &#125; else if index &lt; k-1 &#123; index = partition(arr, index+1, len(arr)-1) &#125; &#125; //到这里说明partition划分为index就是第k个元素，直接返回即可 return arr[:k]&#125; 方法四【最优解】：BFPRT参考 参考58沈剑讲解","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"}],"author":"yirufeng"},{"title":"冒泡排序以及优化","slug":"冒泡排序以及优化","date":"2020-09-10T21:10:00.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2020/09/10/冒泡排序以及优化/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"冒泡排序思路：从左向右每次两两比较相邻元素，如果前一个元素大于后一个元素，那么就交换这两个元素，一趟下来肯定有一个元素放到了最后的位置 12345678910111213141516func BubbleSort(nums []int) []int &#123; bubbleSort(nums) return nums&#125;func bubbleSort(nums []int) &#123; //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1; i++ &#123; for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125;","text":"冒泡排序思路：从左向右每次两两比较相邻元素，如果前一个元素大于后一个元素，那么就交换这两个元素，一趟下来肯定有一个元素放到了最后的位置 12345678910111213141516func BubbleSort(nums []int) []int &#123; bubbleSort(nums) return nums&#125;func bubbleSort(nums []int) &#123; //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1; i++ &#123; for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125; 优化版本的冒泡排序思路：前面的冒泡排序在数组已经有序的时候还仍然会比较，因此我们可以通过设置一个flag，如果某一轮没有交换操作，说明当前已经有序，后面的不需要继续比较和判断了 123456789101112131415161718192021//改进版的冒泡排序：一旦某一趟不交换后面就直接退出func BubbleSortV2(nums []int) []int &#123; bubbleSortV2(nums) return nums&#125;func bubbleSortV2(nums []int) &#123; flag := true //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1 &amp;&amp; flag; i++ &#123; flag = false for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] flag = true &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.sivan.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"直接插入排序以及优化","slug":"直接插入排序以及优化","date":"2020-09-10T09:20:00.000Z","updated":"2022-09-28T06:20:08.864Z","comments":true,"path":"2020/09/10/直接插入排序以及优化/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"直接插入排序直接插入排序是简单排序中性能最好的 平均时间复杂度：O(n^n / 4)最好时间复杂度：O(n)最坏时间复杂度：O(n^n) 直接插入排序版本1思路：将每次要插入的当前元素依次与左边元素比较，如果左边元素大于当前元素则交换，直到左边元素小于等于当前元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSort(nums []int) []int &#123; insertSort(nums) return nums&#125;//思路：如果当前元素比前一个元素小就交换，一直到当前元素大于等于前一个元素func insertSort(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for j := i; j &gt;= 1 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123; nums[j], nums[j-1] = nums[j-1], nums[j] &#125; &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSort(nums))&#125;","text":"直接插入排序直接插入排序是简单排序中性能最好的 平均时间复杂度：O(n^n / 4)最好时间复杂度：O(n)最坏时间复杂度：O(n^n) 直接插入排序版本1思路：将每次要插入的当前元素依次与左边元素比较，如果左边元素大于当前元素则交换，直到左边元素小于等于当前元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSort(nums []int) []int &#123; insertSort(nums) return nums&#125;//思路：如果当前元素比前一个元素小就交换，一直到当前元素大于等于前一个元素func insertSort(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for j := i; j &gt;= 1 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123; nums[j], nums[j-1] = nums[j-1], nums[j] &#125; &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSort(nums))&#125; 直接插入排序版本2 摘自&lt;&lt;大话数据结构&gt;&gt; 思路：将前面比要插入元素大的元素挪到后面，找到插入位置之后将要插入元素插入即可，最后找到的插入位置一定是j+1而不是j因为我们判断了nums[j]小于等于我们要插入的元素 注意：此时要记得将temp放置到正确位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSortV2(nums []int) []int &#123; insertSortV2(nums) return nums&#125;//大话数据结构书上的直接插入排序func insertSortV2(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; temp := nums[i] j := i-1 //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for ; j &gt;= 0 &amp;&amp; nums[j] &gt; temp ; j-- &#123; nums[j+1] = nums[j] &#125; //此时要记得将temp放置到正确位置 nums[j+1] = temp &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; //设置随机数种子 rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSortV2(nums))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"直接插入排序","slug":"直接插入排序","permalink":"http://www.sivan.tech/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"hexo环境搭建(涵盖mac + win)并将我们的博客同步和发布到github","slug":"hexo博客环境搭建","date":"2019-03-21T21:17:42.000Z","updated":"2022-09-28T06:20:08.860Z","comments":true,"path":"2019/03/21/hexo博客环境搭建/","link":"","permalink":"http://www.sivan.tech/2019/03/21/hexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"如果不想使用nvm进行node多版本的管理，直接可以使用去node中文网 下载LTS版本(安装的时候记得添加到环境变量选项要勾上)，安装后从第四步开始执行 第一步：安装nvm 这一步mac和windows有所区别 macwindows 执行curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 或 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 注意：注意后面的v0.33.8这是nvm的版本号，最新版本查看 参考Windows下安装及使用nvm在windows下安装nvm 安装完成后关闭终端，然后键入nvm看一下是否有输出，如果command not found请查看 nvm ls查看所有已安装node的版本，并且使用node use &lt;version&gt;命令选择一个合适的node用来安装hexo 补充：nvm常用命令介绍 123456● nvm install stable 安装最新稳定版 node● nvm install &lt;version&gt; 安装指定版本，如：安装v4.4.0，nvm install v4.4.0● nvm uninstall &lt;version&gt; 删除已安装的指定版本，语法与install类似● nvm use &lt;version&gt; 切换使用指定的版本node● nvm ls 列出所有安装的版本● nvm alias default &lt;version&gt; 如： nvm alias default v11.1.0","text":"如果不想使用nvm进行node多版本的管理，直接可以使用去node中文网 下载LTS版本(安装的时候记得添加到环境变量选项要勾上)，安装后从第四步开始执行 第一步：安装nvm 这一步mac和windows有所区别 macwindows 执行curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 或 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 注意：注意后面的v0.33.8这是nvm的版本号，最新版本查看 参考Windows下安装及使用nvm在windows下安装nvm 安装完成后关闭终端，然后键入nvm看一下是否有输出，如果command not found请查看 nvm ls查看所有已安装node的版本，并且使用node use &lt;version&gt;命令选择一个合适的node用来安装hexo 补充：nvm常用命令介绍 123456● nvm install stable 安装最新稳定版 node● nvm install &lt;version&gt; 安装指定版本，如：安装v4.4.0，nvm install v4.4.0● nvm uninstall &lt;version&gt; 删除已安装的指定版本，语法与install类似● nvm use &lt;version&gt; 切换使用指定的版本node● nvm ls 列出所有安装的版本● nvm alias default &lt;version&gt; 如： nvm alias default v11.1.0 第二步：卸载原来的hexo 删除原来的hexo：npm uninstall -g hexo-cli 第三步：安装node 由于hexo必须要用npm安装，hexo安装的版本取决于node的版本 使用nvm选择我们的node版本，如果对应版本没有安装，首先使用nvm安装对应版本的node。nvm install &lt;version&gt; 切换到对应的node版本：npm use &lt;version&gt; 第四步：安装hexo 安装hexo： npm install -g hexo-cli 第五步：同步并发布自己的博客(CI + CD) 这里假设我们的博客文章已经编写完成 这一部分涉及到两部分内容： (备份)同步博客源内容到github：避免之前编写的博客内容丢失 (发布)将我们编写的博客发布到github：可以以网页的形式看到我们编写之后的内容 具体步骤 在我们的博客根目录下新建.github目录，然后进入.github目录新建workflows目录，进入之后新建deploy.yml文件 键入如下内容：12345678910111213141516171819202122232425262728name: Build and Deployon: push: branches: - sourcejobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions&#x2F;checkout@v2 # If you&#39;re using actions&#x2F;checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built. run: | npm install npm run build env: CI: false - name: Deploy 🚀 uses: JamesIves&#x2F;github-pages-deploy-action@releases&#x2F;v3 with: GITHUB_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BRANCH: main # The branch the action should deploy to. FOLDER: public # The folder the action should deploy. 配置ACCESS_TOKEN 进入github token页面 点击generate new token全选之后将将生成的token赋值 进入自己的用户名.github.io仓库，然后点击settings-&gt;secrets-&gt;New repository secret-&gt;名字是ACCESS_TOKEN，值是刚才生成的token 使用git的add、commit、push 命令提交 注意事项： 博客的源代码存放到 用户名.github.io这个仓库下的source分支下 博客的发布流程我们在上面已经配置到了github的action中，github会在我们push到source分支的时候直接拉取代码然后发布到main分支，之后我们就可以通过用户名.github.io这个域名进行访问了 之后每次提交记得在source分支下操作 后续 博客搭建好之后，只需要选一个合适的主题，就可以书写自己的博客了 参考 GitHub如何配置SSH Key Hexo-5.x 与 NexT-8.x 跨版本升级 【干货】Luke教你20分钟快速搭建个人博客系列(hexo篇) | 自动化部署在线编辑统统搞定 | 前端必会！","categories":[{"name":"blog","slug":"blog","permalink":"http://www.sivan.tech/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.sivan.tech/tags/blog/"}],"author":"yirufeng"}],"categories":[{"name":"C/C++","slug":"C-C","permalink":"http://www.sivan.tech/categories/C-C/"},{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/categories/docker/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"算法","slug":"LeetCode/算法","permalink":"http://www.sivan.tech/categories/LeetCode/%E7%AE%97%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"},{"name":"二叉树","slug":"算法/面试/二叉树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"BFPRT","slug":"算法/BFPRT","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/BFPRT/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"blog","slug":"blog","permalink":"http://www.sivan.tech/categories/blog/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://www.sivan.tech/tags/C-C/"},{"name":"时间","slug":"时间","permalink":"http://www.sivan.tech/tags/%E6%97%B6%E9%97%B4/"},{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"consul","slug":"consul","permalink":"http://www.sivan.tech/tags/consul/"},{"name":"Centos","slug":"Centos","permalink":"http://www.sivan.tech/tags/Centos/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/tags/Linux/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"刷题","slug":"刷题","permalink":"http://www.sivan.tech/tags/%E5%88%B7%E9%A2%98/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"},{"name":"DP","slug":"DP","permalink":"http://www.sivan.tech/tags/DP/"},{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.sivan.tech/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"BFPRT","slug":"BFPRT","permalink":"http://www.sivan.tech/tags/BFPRT/"},{"name":"topK","slug":"topK","permalink":"http://www.sivan.tech/tags/topK/"},{"name":"找第几大或第几小","slug":"找第几大或第几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E7%AC%AC%E5%87%A0%E5%A4%A7%E6%88%96%E7%AC%AC%E5%87%A0%E5%B0%8F/"},{"name":"找前几大或前几小","slug":"找前几大或前几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E5%89%8D%E5%87%A0%E5%A4%A7%E6%88%96%E5%89%8D%E5%87%A0%E5%B0%8F/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"桶排序","slug":"桶排序","permalink":"http://www.sivan.tech/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.sivan.tech/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.sivan.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"直接插入排序","slug":"直接插入排序","permalink":"http://www.sivan.tech/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.sivan.tech/tags/blog/"}]}
---
title: 求两颗树的第一个交点
author: yirufeng
pin: false
toc: true
mathjax: false
sidebar:
  - blogger
  - webinfo
  - tagcloud
  - category
categories:
  - 算法
tags:
  - 树
date: 2017-11-27 18:47:17
summary:
---


## 求两棵树的第一个交点
> 首先判断两棵树是否相交，可以根据判断两个链表是否相交扩展而来，如果相交的话，将第1个链表的末尾指向第1个链表的头部将会成环，因此借鉴这种思路

自己的思路如下：![KlYSSU](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/KlYSSU.png)


### 验证两棵树是否相交
思路：Morris先序遍历，遍历第1棵树的时候将叶节点的左指针指向root1，然后遍历root2，如果发现某一个节点左指针指向第1个树根，说明相交，**包含了两个树中有一个是子树的情况**

时间复杂度：O(N)
空间复杂度：O(1)
<!--more -->

{% folding green, 验证两棵树是否相交代码 %}
```go
//判断两个树是否相交
//采用Morris先序遍历可以在时间复杂度不变的情况下将空间复杂度将为O(1)
func ifIntersection(root1, root2 *TreeNode) bool {
	//有一个为空，说明不相交
	if root1 == nil || root2 == nil {
		return false
	}

	//Morris先序遍历树1：第一个树的叶子节点的左指针指向第一个树根
	var prev *TreeNode
	cur := root1
	for cur != nil {
		if cur.Left == nil && cur.Right == nil {
			cur.Left, cur = root1, cur.Right
		} else if cur.Left == root1 {
			cur = cur.Right
		} else {
			prev = cur.Left
			for (prev.Right != nil) && (prev.Right != cur) { //找到左子树的最右节点
				prev = prev.Right
			}
			//如果最右节点的左子树为空，则指向root1
			if prev.Left == nil {
				prev.Left = root1
			}

			if prev.Right == nil { //找到了最右节点
				prev.Right = cur
				cur = cur.Left
			} else { //此时就是最右节点，只不过此时最右节点的右指针指向的不是nil，所以要置nil
				prev.Right = nil
				cur = cur.Right
			}
		}
	}
	//Morris先序遍历树2：如果遍历的时候发现左指针指向第1个树根，说明相交
	cur, prev = root2, nil
	var ret bool
	for cur != nil {
		if cur.Left == root1 {
			ret, cur.Left = true, nil
		} else if cur.Left == nil {
			//如果当前节点是叶子节点
			if cur.Right == nil {
				cur.Left = nil
			}
			cur = cur.Right
		} else {
			prev = cur.Left
			for (prev.Right != nil) && (prev.Right != cur) { //找到左子树的最右节点
				prev = prev.Right
			}
			if prev.Left == root1 {
				prev.Left = nil
				ret = true
			}

			if prev.Right == nil { //找到了最右节点
				//判断是否为叶子节点
				if prev.Left == root1 {
					prev.Left = nil
					ret = true
				}
				prev.Right = cur
				cur = cur.Left
			} else { //此时就是最右节点，只不过此时最右节点的右指针指向的不是nil，所以要置nil
				prev.Right = nil
				cur = cur.Right
			}
		}
	}

	return ret
}
```
{% endfolding %}


### 求出两棵树相交的第一个交点

#### 最优解法：
思路：
1. Morris先序遍历树1，如果是非叶节点加入到哈希表中，如果是叶子节点将左指针指向树1的根
2. Morris先序遍历树2，如果遍历到某个非叶节点发现已经在哈希表中，直接返回该节点，如果遍历到叶子节点的时候发现左指针指向树1的跟，直接返回该节点

时间复杂度:O（N）
空间复杂度：O（m） m为非叶节点的个数

{% folding green, 最优解法 %}
```go
//方法二：找到两个相交树的第一个交点
//按照群里老哥提供的解法：(使用morris遍历不需要借助任何数组)遍历到第1个树，如果是非叶子节点，则加入到我们的哈希表，如果是叶子节点，则左指针指向我们的根
//返回是否相交，以及相交的第一个节点（如果第一个相交的点在叶节点上是不需要借助哈希表的，但是如果在非叶节点上相交是需要借助哈希表的）
//改正中
func SolutionII(root1, root2 *TreeNode) (bool, *TreeNode) {
	//判断是否相交的过程中找到第一个相交的节点
	//有一个为空，说明不相交
	if root1 == nil || root2 == nil {
		return false, nil
	}

	var ifIntersection bool
	var intersectionNode *TreeNode

	hashmap := make(map[*TreeNode]bool)

	//Morris先序遍历树1：第一个树的叶子节点的左指针指向第一个树根
	var mostRight *TreeNode
	cur := root1
	for cur != nil {

		//如果当前节点没有左子树
		if cur.Left == nil { //当前节点向右移动  (只有没有左子树的节点会走这一步)
			if cur.Right == nil {
				cur.Left = root1
			}
			hashmap[cur] = true
			cur = cur.Right
		} else if cur.Left == root1 {
			cur = cur.Right
		} else { //找到当前节点左子树的最右节点
			mostRight = cur.Left
			for mostRight.Right != nil && mostRight.Right != cur {
				mostRight = mostRight.Right
			}
			//此时mostRight就是当前节点左子树的最右节点
			if mostRight.Right == nil { //说明是第一次来到
				//加入到我们的哈希表，因为不是叶节点
				hashmap[cur] = true
				mostRight.Right, cur = cur, cur.Left
			} else { //说明是第二次来到(只有有左子树的时候才会有第二次来到)
				mostRight.Right, cur = nil, cur.Right
			}
		}
	}
	//遍历完之后，只有叶子节点的左指针都指向root1并且所有节点都加入到我们的hashmap中
	//Morris先序遍历树2：如果遍历的时候发现左指针指向第1个树根，说明相交
	cur, mostRight = root2, nil
	for cur != nil {

		//如果当前节点的左子树为root1
		if cur.Left == root1 || cur.Left == nil{ //叶 || 有右的非叶
			if _, ok := hashmap[cur]; ok && intersectionNode == nil {
				ifIntersection, intersectionNode = true, cur
			}
			cur = cur.Right
		} else { //找到当前节点左子树的最右节点
			mostRight = cur.Left
			for mostRight.Right != nil && mostRight.Right != cur {
				mostRight = mostRight.Right
			}
			//此时mostRight就是当前节点左子树的最右节点
			if mostRight.Right == nil { //说明是第一次来到
				if _, ok := hashmap[cur]; ok && intersectionNode == nil {
					ifIntersection, intersectionNode = true, cur
				}
				mostRight.Right, cur = cur, cur.Left
			} else { //说明是第二次来到(只有有左子树的时候才会有第二次来到)
				mostRight.Right, cur = nil, cur.Right
			}
		}
	}
	return ifIntersection, intersectionNode
}
```
{% endfolding %}



#### 暴力解法
思路：
1. 时间复杂度：O(N) 
2. 空间复杂度：O(N)



{% folding green, 暴力解法 %}
```go
//暴力：使用哈希表
//方法一：暴力解法，使用哈希表将树1层次遍历的结果保存到我们的哈希表中，然后遍历树2，如果节点出现在哈希表中就返回该节点
func SolutionI(root1, root2 *TreeNode) *TreeNode {
	//有一个为空就直接返回nil
	if root1 == nil || root2 == nil {
		return nil
	}

	hashmap := make(map[*TreeNode]bool)
	queue := []*TreeNode{root1}
	for len(queue) != 0 {
		node := queue[0]
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}

		//注意：遍历的时候一定要将节点加入进去
		hashmap[node] = true
		queue = queue[1:]
	}

	//然后遍历树2
	queue = append(queue, root2)
	for len(queue) != 0 {
		node := queue[0]

		//遍历树2的时候，如果有一个节点已经在我们的哈希表中，直接返回结果
		if _, ok := hashmap[node]; ok {
			fmt.Println(node.Val)
			return node
		}
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
		queue = queue[1:]
	}

	return nil
}
```
{% endfolding %}


### 最后完整代码如下
{% folding green, 最后完整代码 %}
```go
package main

import "fmt"

/**
 * @Author: yirufeng
 * @Date: 2021/11/27 6:43 下午
 * @Email: yirufeng@foxmail.com
 * @GitHub: https://www.github.com/sivanWu0222
 * @Desc: 这里写的是一个二叉树的交点，多叉树直接使用哈希表
 **/

type TreeNode struct {
	Val         int
	Left, Right *TreeNode
}

//判断两个树是否相交
//采用Morris先序遍历可以在时间复杂度不变的情况下将空间复杂度将为O(1)
func ifIntersection(root1, root2 *TreeNode) bool {
	//有一个为空，说明不相交
	if root1 == nil || root2 == nil {
		return false
	}

	//Morris先序遍历树1：第一个树的叶子节点的左指针指向第一个树根
	var prev *TreeNode
	cur := root1
	for cur != nil {
		if cur.Left == nil && cur.Right == nil {
			cur.Left, cur = root1, cur.Right
		} else if cur.Left == root1 {
			cur = cur.Right
		} else {
			prev = cur.Left
			for (prev.Right != nil) && (prev.Right != cur) { //找到左子树的最右节点
				prev = prev.Right
			}
			//如果最右节点的左子树为空，则指向root1
			if prev.Left == nil {
				prev.Left = root1
			}

			if prev.Right == nil { //找到了最右节点
				prev.Right = cur
				cur = cur.Left
			} else { //此时就是最右节点，只不过此时最右节点的右指针指向的不是nil，所以要置nil
				prev.Right = nil
				cur = cur.Right
			}
		}
	}
	//Morris先序遍历树2：如果遍历的时候发现左指针指向第1个树根，说明相交
	cur, prev = root2, nil
	var ret bool
	for cur != nil {
		if cur.Left == root1 {
			ret, cur.Left = true, nil
		} else if cur.Left == nil {
			//如果当前节点是叶子节点
			if cur.Right == nil {
				cur.Left = nil
			}
			cur = cur.Right
		} else {
			prev = cur.Left
			for (prev.Right != nil) && (prev.Right != cur) { //找到左子树的最右节点
				prev = prev.Right
			}
			if prev.Left == root1 {
				prev.Left = nil
				ret = true
			}

			if prev.Right == nil { //找到了最右节点
				//判断是否为叶子节点
				if prev.Left == root1 {
					prev.Left = nil
					ret = true
				}
				prev.Right = cur
				cur = cur.Left
			} else { //此时就是最右节点，只不过此时最右节点的右指针指向的不是nil，所以要置nil
				prev.Right = nil
				cur = cur.Right
			}
		}
	}

	return ret
}

//暴力：使用哈希表
//方法一：暴力解法，使用哈希表将树1层次遍历的结果保存到我们的哈希表中，然后遍历树2，如果节点出现在哈希表中就返回该节点
func SolutionI(root1, root2 *TreeNode) *TreeNode {
	//有一个为空就直接返回nil
	if root1 == nil || root2 == nil {
		return nil
	}

	hashmap := make(map[*TreeNode]bool)
	queue := []*TreeNode{root1}
	for len(queue) != 0 {
		node := queue[0]
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}

		//注意：遍历的时候一定要将节点加入进去
		hashmap[node] = true
		queue = queue[1:]
	}

	//然后遍历树2
	queue = append(queue, root2)
	for len(queue) != 0 {
		node := queue[0]

		//遍历树2的时候，如果有一个节点已经在我们的哈希表中，直接返回结果
		if _, ok := hashmap[node]; ok {
			fmt.Println(node.Val)
			return node
		}
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
		queue = queue[1:]
	}

	return nil
}

//方法二：找到两个相交树的第一个交点
//按照群里老哥提供的解法：(使用morris遍历不需要借助任何数组)遍历到第1个树，如果是非叶子节点，则加入到我们的哈希表，如果是叶子节点，则左指针指向我们的根
//返回是否相交，以及相交的第一个节点（如果第一个相交的点在叶节点上是不需要借助哈希表的，但是如果在非叶节点上相交是需要借助哈希表的）
//改正中
func SolutionII(root1, root2 *TreeNode) (bool, *TreeNode) {
	//判断是否相交的过程中找到第一个相交的节点
	//有一个为空，说明不相交
	if root1 == nil || root2 == nil {
		return false, nil
	}

	var ifIntersection bool
	var intersectionNode *TreeNode

	hashmap := make(map[*TreeNode]bool)

	//Morris先序遍历树1：第一个树的叶子节点的左指针指向第一个树根
	var mostRight *TreeNode
	cur := root1
	for cur != nil {

		//如果当前节点没有左子树
		if cur.Left == nil { //当前节点向右移动  (只有没有左子树的节点会走这一步)
			if cur.Right == nil {
				cur.Left = root1
			}
			hashmap[cur] = true
			cur = cur.Right
		} else if cur.Left == root1 {
			cur = cur.Right
		} else { //找到当前节点左子树的最右节点
			mostRight = cur.Left
			for mostRight.Right != nil && mostRight.Right != cur {
				mostRight = mostRight.Right
			}
			//此时mostRight就是当前节点左子树的最右节点
			if mostRight.Right == nil { //说明是第一次来到
				//加入到我们的哈希表，因为不是叶节点
				hashmap[cur] = true
				mostRight.Right, cur = cur, cur.Left
			} else { //说明是第二次来到(只有有左子树的时候才会有第二次来到)
				mostRight.Right, cur = nil, cur.Right
			}
		}
	}
	//遍历完之后，只有叶子节点的左指针都指向root1并且所有节点都加入到我们的hashmap中
	//Morris先序遍历树2：如果遍历的时候发现左指针指向第1个树根，说明相交
	cur, mostRight = root2, nil
	for cur != nil {

		//如果当前节点的左子树为root1
		if cur.Left == root1 || cur.Left == nil{ //叶 || 有右的非叶
			if _, ok := hashmap[cur]; ok && intersectionNode == nil {
				ifIntersection, intersectionNode = true, cur
			}
			cur = cur.Right
		} else { //找到当前节点左子树的最右节点
			mostRight = cur.Left
			for mostRight.Right != nil && mostRight.Right != cur {
				mostRight = mostRight.Right
			}
			//此时mostRight就是当前节点左子树的最右节点
			if mostRight.Right == nil { //说明是第一次来到
				if _, ok := hashmap[cur]; ok && intersectionNode == nil {
					ifIntersection, intersectionNode = true, cur
				}
				mostRight.Right, cur = cur, cur.Left
			} else { //说明是第二次来到(只有有左子树的时候才会有第二次来到)
				mostRight.Right, cur = nil, cur.Right
			}
		}
	}
	return ifIntersection, intersectionNode
}

func main() {
	var root1, root2 *TreeNode
	//不相交
	root1, root2 = &TreeNode{Val: 1, Left: &TreeNode{Val: 2}, Right: &TreeNode{Val: 3}}, &TreeNode{Val: 4, Left: &TreeNode{Val: 5, Left: &TreeNode{Val: 7}, Right: &TreeNode{Val: 8}}, Right: &TreeNode{Val: 6, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 10}}}
	fmt.Println(ifIntersection(root1, root2)) //false
	fmt.Println(SolutionII(root1, root2))     //false
	//一个树不是另一个树的子树并且相交于叶节点
	node := &TreeNode{Val: 5}
	root1, root2 = &TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 4}, Right: node}, Right: &TreeNode{Val: 3}}, &TreeNode{Val: 6, Left: node, Right: &TreeNode{Val: 7}}
	fmt.Println(ifIntersection(root1, root2))
	fmt.Println(SolutionII(root1, root2))
	//一个树不是另一个树的子树并且相交于非叶子节点
	node = &TreeNode{Val: 3, Left: &TreeNode{Val: 6}, Right: &TreeNode{Val: 7}}
	root1, root2 = &TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 4}, Right: &TreeNode{Val: 5}}, Right: node}, &TreeNode{Val: 8, Left: node, Right: &TreeNode{Val: 9}}
	fmt.Println(ifIntersection(root1, root2))
	fmt.Println(SolutionII(root1, root2))
	//一个树是另一个树的子树
	node = &TreeNode{Val: 3, Left: &TreeNode{Val: 6}, Right: &TreeNode{Val: 7}}
	root1, root2 = &TreeNode{Val: 1, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 4}, Right: &TreeNode{Val: 5}}, Right: node}, node
	fmt.Println(ifIntersection(root1, root2))
	fmt.Println(SolutionII(root1, root2))
}

```
{% endfolding %}


---
title: 微服务项目实战
author: yirufeng
pin: false
toc: true
mathjax: false
sidebar:
  - blogger
  - webinfo
  - tagcloud
  - category
categories:
  - null
tags:
  - null
  - null
date: 2021-05-10 09:23:10
summary:
---


## 微服务基础

{% folding green, 微服务，微服务架构，微服务框架 %}
![NtTOTv](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NtTOTv.png)
![brTPTu](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/brTPTu.png)
1. 微服务：应该使用这种方法而设计的一个应用，也就是设计出来的一个应用
2. 微服务架构：一种设计方法
3. 微服务框架（比如我们后面用到的micro）：将复杂的系统使用组件化的方式进行拆分，并且使用轻量级通讯方式进行整合的一种设计方法。微服务是通过这种架构设计方法拆分出来的一个独立的组件化的小应用。

注意：这3个概念不一样
{% endfolding %}



{% folding green, 微服务架构与整体式架构的区别 %}
单体式开发的缺点：
1. 复杂性逐渐变高
2. 技术债务逐渐上升
3. 维护成本大
4. 持续交付周期长
5. 可扩展性差
{% endfolding %}


{% folding green, 微服务架构的特点 %}
1. ![oLKc0q](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/oLKc0q.png) ：这张图将我们的服务都拆分出来了，想使用哪个直接访问就可以了，不需要使用集中式的，每一个业务单独配置。
2. 单一职责：微服务架构中的每个服务，都是具有业务逻辑的，复合高内聚，低耦合的原则以及单一职责原则的单元，不同的服务通过管道的方式灵活组合，从而构建出庞大的系统
3. 轻量级通信：服务之间通过轻量级的通信机制实现互通互联，所谓的轻量级，通常是指语言无关、平台无关的交互方式。
4. ![bJpiiz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/bJpiiz.png) ：restful是一种风格，满足了我们的rest这个规则
5. ![1h2Exi](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1h2Exi.png) -> ![kTR8VY](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/kTR8VY.png)
6. ![VMS2m6](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VMS2m6.png)：![b6lKUC](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/b6lKUC.png)

{% endfolding %}

{% folding green, 微服务架构的缺点  %}
> ![6rJkXr](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/6rJkXr.png)

1. 分布式微服务与传统的区别：![T2ldhl](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/T2ldhl.png)
2. 为什么使用微服务架构：![RaMkeC](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/RaMkeC.png)
3. 扩充业务：![Oy0Drw](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Oy0Drw.png)
4. 去掉影响的服务：![kR1L1D](https://cdn.jsdeliv r.net/gh/sivanWu0222/ImageHosting@master/uPic/kR1L1D.png)
5. 升级服务：![sZgVzB](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/sZgVzB.png)

{% endfolding %}

{% folding green, 微服务课程的几个重要组件 %}
1. 跨语言，跨平台的通信：protobuf
2. 通信协议：gRPC
3. 服务的调度服务发现：consul
4. 微服务的框架：micro
5. 微服务部署：docker
{% endfolding %}

## protobuf



{% folding green, 了解 %}
1. ![QOAocV](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/QOAocV.png)
2. 介绍：![0Qevoj](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/0Qevoj.png)
3. 对比：![5jYYAz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/5jYYAz.png)
4. protobuf的优点：![8ewsJG](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/8ewsJG.png)
5. protobuf的缺点：![MAxYdS](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/MAxYdS.png)

我们写一个.proto的文件，然后生成到不同语言对应的文件，比如go会生成.go的文件
{% endfolding %}

{% folding green, protobuf安装 %}

1. 首先使用`protoc -h`测试是否安装
2. ![St1qqL](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/St1qqL.png)
3. 获取proto包：`go get -v -u github.com/golang/protobuf/proto` 如果是离线安装，我们需要将下载的代码放置到src下面的github.com目录下，然后执行`go build`生成`protoc-gen-go`，将这个`protoc-gen-go`移动到/bin目录下
4. 安装protoc-gen-go插件：![sU6aZo](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/sU6aZo.png)

知识点：`go get`中`-v`与`-u`的作用
-v :显示操作流程的日志及信息，方便检查错误
-u 如果需要依赖的时候会下载依赖,也就是下载丢失的包，但不会更新已经存在的包
{% endfolding %}

{% folding green, protobuf的基本语法 %}
1. 要使用protobuf必须得先定义proto文件，所以得先熟悉protobuf的消息定义的相关语法
2. 定义一个消息类型：![FmgLtN](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/FmgLtN.png)
```proto
syntax = "proto3"; //表明现在使用的是proto3的语法，如果不指定这个编译器将会使用proto2。这个指定的与发行必须是文件的非空非注释的第一行。
option go_package = "./Message";  //指定将我们的go文件生成到哪个目录
//定义一个消息类型：消息定义中，每一个子弹都有唯一的一个标识符，也就是对应的序号
message PandaRequest {
    //数据类型 变量名 = 序号;
    string name = 1;
    int32 height = 2;
    //repeated表示重复的，相当于golang里面的切片，
    //repeated后面跟一个数据类型表示切片中元素的数据类型
    repeated int32 weight = 3;
}
```
3. 向proto文件中添加注释：可以使用`//`的语法格式。![4qE56u](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/4qE56u.png)
4. ![JdePab](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/JdePab.png)
5. 生成对应的语言的代码：![r9HtxF](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/r9HtxF.png) + ![2xUpX2](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/2xUpX2.png)
`protoc --go_out指定生成的go的目录 proto文件所在的目录/生成go文件的proto文件` 例如: `protoc --go_out=./ ./proto/*.proto`
由于我们自己的环境与老师的不一样，我们还得在proto文件中加上这么一句话`option go_package = "./Message";  //指定将我们的go文件生成到哪个目录，这个目录是相对于我们命令protoc中的参数go_out而言的相对目录`
6. 数据类型：![hXFnVM](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/hXFnVM.png) + ![fARK68](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/fARK68.png) + ![p8SAfz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/p8SAfz.png)
7. 如果有一些格式文件比较复杂，我们都建议用go语言的[]byte然后对应protobuf的bytes类型进行传输，相当好使，因为是二进制传输。
8. ![PsYxhK](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/PsYxhK.png) ，比如： ![YLsZgJ](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/YLsZgJ.png)
9. 嵌套类型：![kaNhHq](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/kaNhHq.png)
10. 定义服务(grpc的时候用到, grpc是rpc的一个升级版本)：![NYsL6R](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NYsL6R.png) , 传入的参数以及返回的参数都是我们的message
11. ![jcloDc](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/jcloDc.png) +
12. 测试文件：
    1. ![v1YrEw](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/v1YrEw.png)
    2. ![38F4jo](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/38F4jo.png)
    3. 将我们编写的proto编译成go文件
    4. 编码并解码：![dLduny](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/dLduny.png) + ![DSXRmT](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/DSXRmT.png)

一般流程：编写消息和服务 -> 生成对应的go的代码 -> 通过grpc来进行远程调用
快捷键：command + b 快速进入到代码内部的实现中
{% endfolding %}

## rpc

{% folding green, rpc的客户端与服务端 %}
1. ![EBtoRz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/EBtoRz.png)
2. ![x3kepP](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/x3kepP.png)
3. 远程过程调用流程图：![FBB2mV](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/FBB2mV.png) + 过程： ![2gUZj0](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/2gUZj0.png)
4. go内部也是有一个rpc库的，我们可以直接使用， ![iBp4Xx](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/iBp4Xx.png) + ![GKuZkk](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/GKuZkk.png) + 注册：![k9Bia9](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/k9Bia9.png) + 连接到网络： ![n6OBSX](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/n6OBSX.png) + 编写客户端：![sjJAqe](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/sjJAqe.png)
{% endfolding %}


{% folding green, rpc的调用流程讲解 %}
1. 过程图：![7n41N3](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/7n41N3.png)
2. 对着代码进行讲解：![p2Wa5w](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/p2Wa5w.png)
	1. 左边的建立连接返回一个cli句柄
	2. 我们通过cli.call调用远程函数，并且带了传参和接收返回
    3. 服务端注册完之后就会作为服务暴露出来，随之函数也就会被暴露出来，之后我们就可以通过rpc进行调用
{% endfolding %}

{% folding green, rpc客户端代码 %}

```go
package main

import (
	"fmt"
	"net/rpc"
)

/**
 * @Author: yirufeng
 * @Date: 2021/5/10 10:05 上午
 * @Desc:
 **/

func main() {
	cli, err := rpc.DialHTTP("tcp", "127.0.0.1:10086")
	defer cli.Close()
	if err != nil {
		panic(err)
	}

	var pd int

	err = cli.Call("Panda.GetInfo", 100, &pd)
	if err != nil {
		panic(err)
	}

	fmt.Println(pd)

}
```
{% endfolding %}
{% folding green, rpc服务端代码 %}
```go
package main

import (
	"fmt"
	"io"
	"net"
	"net/http"
	"net/rpc"
)

/**
 * @Author: yirufeng
 * @Date: 2021/5/10 10:05 上午
 * @Desc:
 **/

type Panda int

//只有满足如下3个标准的方法才可以用于远程访问
//1. 方法是可以导出的
//2. 方法的第二个参数是指针
//3. 方法只有一个error接口类型的返回值
//方法的第一个参数表示调用者提供的参数，第二个参数代表返回给调用者的参数
//方法的返回值如果不是nil，将会被作为字符串回传，在客户端看来与errors.New()创建的一样
//如果返回了错误，回复的参数不会发送给客户端
func (p *Panda) GetInfo(argType int, replyType *int) error {
	fmt.Println("方法调用者传递过来的参数：", argType)

	//修改内容值
	*replyType = argType + 100

	return nil
}

func main() {

	//编写一个处理请求的handler
	http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		io.WriteString(w, "hello world!")
	})
	//实例化一个结构体的对象
	pd := new(Panda)
	//服务端注册一个对象
	rpc.Register(pd)
	rpc.HandleHTTP()
	ln, err := net.Listen("tcp", ":10086")
	if err != nil {
		panic(err)
	}
	http.Serve(ln, nil)
}
```
{% endfolding %}

## grpc



{% folding green, grpc基本概念 %}
1. ![Ui4EwW](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Ui4EwW.png)
2. ![UCYMlT](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/UCYMlT.png)
{% endfolding  %}

{% folding green, grpc环境搭建 %}
对于采用mod工具管理的项目：直接使用命令：`go get google.golang.org/grpc`来下载我们的grpc
{% endfolding %}

{% folding green, 客户端代码与服务端代码介绍 %}
1. 编写我们的protobuf协议的内容：
```protobuf
syntax = "proto3";

package myproto;

option go_package = "./myproto";


//客户端发送给服务端的
message HelloRequest {
  string name = 1;
}

//服务端返回给客户端的
message HelloResponse {
  string msg = 1;
}


//客户端向服务端发送的请求
message NameRequest {
  string name = 1;
}

//服务端返回给客户端的响应
message NameResponse {
  string msg = 1;
}



//定义服务
service HelloService {
  //函数的传入和传出就是我们自己要定义的消息类型
  //一个打招呼的函数
  rpc SayHello (HelloRequest) returns (HelloResponse) {}
  //一个说名字的函数
  rpc SayName (NameRequest) returns (NameResponse) {}
}
```
2. 我们使用`protoc --go_out=. ./myproto/*.proto`生成之后发现没有rpc对应的方法。
3. 我们需要插件进行生成：`protoc --go_out=plugins=grpc:. ./myproto/*.proto`。![Qzwkro](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Qzwkro.png)
4. 编写grpc服务端：
```go
package main

/**
 * @Author: yirufeng
 * @Date: 2021/5/10 4:34 下午
 * @Desc: 手动写一个grpc_server
 **/

import (
	"context"
	"fmt"
	"go-project/myproto"
	"google.golang.org/grpc"
	"net"
)

type server struct {
}

func (this *server) SayHello(ctx context.Context, request *myproto.HelloRequest) (out *myproto.HelloResponse, err error) {
	return &myproto.HelloResponse{
		Msg: "你好," + request.Name,
	}, nil
}

func (this *server) SayName(ctx context.Context, request *myproto.NameRequest) (out *myproto.NameResponse, err error) {
	return &myproto.NameResponse{
		Msg: "你的名字是：" + request.Name,
	}, nil
}

func main() {
	//创建网络
	ln, err := net.Listen("tcp", ":10086")
	if err != nil {
		fmt.Println("网络错误,", err)
	}
	//创建grpc的服务
	srv := grpc.NewServer()
	//注册服务
	myproto.RegisterHelloServiceServer(srv, &server{})
	//监听网络并等待网络连接
	err = srv.Serve(ln)
	if err != nil {
		fmt.Println("网络错误：", err)
	}
}
```
5. 编写grpc客户端：
```go
package main

import (
	"context"
	"fmt"
	"go-project/myproto"
	"google.golang.org/grpc"
)

/**
 * @Author: yirufeng
 * @Date: 2021/5/10 4:53 下午
 * @Desc:
 **/

func main() {

	//客户端连接服务器
	conn, err := grpc.Dial("127.0.0.1:10086", grpc.WithInsecure())
	if err != nil {
		fmt.Println("网络异常：", err)
	}

	//延迟关闭连接
	defer conn.Close()

	//获得grpc的句柄
	client := myproto.NewHelloServiceClient(conn)

	//通过句柄调用函数
	//第一个参数是context，我们传一个默认的context就可以的
	ret, err := client.SayHello(context.Background(), &myproto.HelloRequest{
		Name: "yirufneg",
	})
	if err != nil {
		fmt.Println("调用SayHello失败：", err)
	}
	fmt.Println("调用SayHello的返回值：", ret)
	ret2, err := client.SayName(context.Background(), &myproto.NameRequest{
		Name: "yirufneg",
	})
	if err != nil {
		fmt.Println("调用SayName失败：", err)
	}
	fmt.Println("调用SayName的返回值：", ret2)
}
```

引申出的两个问题：
1. 客户端如果不写网路的话，肯定会找不到对应地址的服务端。
2. 如果服务端不启动的时候，客户端建立对话的时候肯定找不到。

{% endfolding %}

## 了解服务发现之consul

{% folding green, 背景 %}
上节课的时候我们服务经常会遇到如下的问题：
1. 客户端连接服务器的时候，IP去掉将无法连接服务器：`conn, err := grpc.Dial("127.0.0.1:10086", grpc.WithInsecure()`
2. 如果先运行客户端再运行服务端，客户端将会报错。

![aF6Aak](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/aF6Aak.png)
这些问题都需要解决，因此我们需要通过服务发现来解决这些问题
{% endfolding %}

{% folding green, consul中的基本概念 %}
1. 通过服务发现来管理服务：![hjwDSP](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/hjwDSP.png)
2. consul的代码并没有开源
3. 故障检测使得如果有服务挂掉，之后请求的时候将会停止访问我们的服务
4. 一个简单的案例：![25Ol7t](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/25Ol7t.png)
5. ![gbYtWf](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/gbYtWf.png)  ![BoFnOg](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/BoFnOg.png)
6. 服务注册：就是服务主动去consul那里登记，服务发现就是指请求过来之后去consul那里查询对应的服务，此时就是服务发现 ![m7vwPH](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/m7vwPH.png)  ![zlqs9v](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zlqs9v.png)
7. ![Nbh3Ph](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Nbh3Ph.png) ![Tpo1VP](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Tpo1VP.png)
{% endfolding %}

{% folding green, consul安装 %}
1. ![7znMCe](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/7znMCe.png)
2. ![J2kwru](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/J2kwru.png)
3. 命令：![vtxNib](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/vtxNib.png)
4. ![zT7xfI](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zT7xfI.png)

consul中的角色：
1. client接收请求，然后将我们的请求转发给对应的server。
2. server做配置保存以及高可用的集群，并在局域网内与我们的client进行通信，并且负责通过广域网与其他数据中心通讯。

agent不是client就是server
{% endfolding %}

{% folding green, consul集群搭建 %}
> 环境：3个虚拟机

1. 192.168.110.123
2. 192.168.110.148
3. 192.168.110.124


步骤：![FjtqZl](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/FjtqZl.png)
1. 192.168.110.123 主机执行命令：`consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -bind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -client 0.0.0.0` + ![VNkw1J](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VNkw1J.png)
2. 192.168.110.148 主机执行命令：`consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -bind=192.168.110.148 -ui -rejoin -join 192.168.110.123`  + ![VnyBD7](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VnyBD7.png) ： ![URYZtv](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/URYZtv.png)  + 访问：![94F8s8](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/94F8s8.png)
3. 148机器访问：![TppyO2](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/TppyO2.png)
4. 192.168.110.124主机执行命令： `consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir /etc/consuld.d -rejoin -join 192.168.110.123` + ![qFexDB](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/qFexDB.png)
5. 148机器访问：![RbrG6L](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/RbrG6L.png)


其他命令:
1. 查看集群成员：![Pvx6iX](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Pvx6iX.png) + ![GYuxXb](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/GYuxXb.png)
2. 查看consul版本：`consul version`
3. 停止Agent：![NEl3cO](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NEl3cO.png)
4. `consul leave` 用于退出集群

{% endfolding %}

{% folding green, consul 服务注册 %}
1. ![tp72FN](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/tp72FN.png)
2. ![1fRIrx](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1fRIrx.png)
3. 测试程序：![1J8DIk](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1J8DIk.png)

> 在micro中我们不需要手动写consul的配置文件
{% endfolding %}

{% folding green, consul扩展 %}
1. ![xv7foa](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/xv7foa.png)
2. consul架构图：![UwSjSy](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/UwSjSy.png) 如果要跨域（图中的黑色）：通过网络进行连接。
3. ![9ZWjlz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/9ZWjlz.png)
4. ![JPZ2Ag](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/JPZ2Ag.png)
5. ![zU0oLv](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zU0oLv.png)

client不做信息持久化保存。

{% endfolding %}


consul参考资料：
1. [参考1](https://www.liangxiansen.cn/2017/04/06/consul)
2. [参考2](https://blog.csdn.net.yuanyuanispeak/article/details/54880743)

## micro

{% folding green, micro介绍 %}
1. ![SVxO9C](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/SVxO9C.png)
2. micro是一个分布式工具也是一个内部的组件
{% endfolding %}

{% folding green, micro安装 %}
1. ![HyFVcL](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/HyFVcL.png)

补充：
1. 官方网站：![pPcGyJ](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/pPcGyJ.png)
2. 自己下去可以看一下micro中文的文档
3. go-micro默认是rpc，我们要用grpc进行一下升级
{% endfolding %}

{% folding green, micro自己安装 %}
1. ![6iZ6xf](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/6iZ6xf.png)
2. ![2p9cOg](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/2p9cOg.png)
3. ![mIAtjq](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/mIAtjq.png)
{% endfolding %}

{% folding green, micro环境搭建以及基本演示 %}
1. ![CAOi2I](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/CAOi2I.png) + ![4elFlk](https://cdn.jsdelivr	.net/gh/sivanWu0222/ImageHosting@master/uPic/4elFlk.png)
2. ![EdUTko](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/EdUTko.png)
3. ![2AdThr](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/2AdThr.png) ：我们可以用DOCKERFILE将我们的单个服务升级成对应的镜像
4. ![HwImoa](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/HwImoa.png)
5. ![NJNPtz](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NJNPtz.png)
6. ![7IuBKb](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/7IuBKb.png)
{% endfolding %}



{% folding green, 两个命令生成srv文件以及web文件 %}
1. `micro new --type "srv" day2/micro/rpc.web`
2. `micro new --type "web" day2/micro/rpc.web`

{% endfolding %}

{% folding green,  %}



{% endfolding %}




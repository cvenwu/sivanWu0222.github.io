---
title: 固定长度的数组实现队列
author: yirufeng
top: true
toc: true
mathjax: false
summary: 固定长度的数组实现队列
categories: 
	- 算法
	- 数据结构
tags:
  - 算法
  - 数据结构
  - 队列
date: 2020-09-26 20:42:00
---

## 题目描述
{% noteblock done %}
使用一个固定长度大小的数组实现队列
{% endnoteblock %}

## 思路
{% folding cyan open,  思路：使用start指向队头，end指向队尾的下一个位置 %}
1. 我们加了一个标志位empty区分start等于end的两种情况，一种是队列中没有元素，另外一种是队列元素满。
2. 如果要弹出元素，需要判断end是否等于start，如果empty为真且start等于end，说明不可以弹出，否则可以弹出元素。
3. 如果要加入元素，直接加入到end指向的位置，之后end需要判断是否处于最后一个位置，如果是则跳转到数组第1个位置，否则end++。同时判断是否满元素来更新empty
{% endfolding %}

<!-- more -->

## 具体实现
{% folding cyan, 实现代码 %}
```go
package main

import (
	"fmt"
	"log"
)

/**
 * @Author: yirufeng
 * @Email: yirufeng@foxmail.com
 * @Date: 2020/9/26 7:41 下午
 * @Desc: 固定长度的数组实现队列
 */

/*
固定长度的数组实现队列
因为Golang数组长度是确定的，所以这里我们使用一个长度为5的数组作为演示
 */
type Queue struct {
	data       [5]int
	start, end int  //指向队头位置,end指向下一个可以插入数据元素的位置
	empty      bool //加了一个标志位来区分是满了还是没有元素
}

//队列加入元素
func (q *Queue) Push(x int) {
	//说明队列满了
	if q.start == q.end && !q.empty {
		log.Println("加入元素------------>无法加入，队列满了")

		return
	}

	q.data[q.end] = x
	if q.end == 4 {
		q.end = 0 //从0开始
	} else {
		q.end++
	}

	if q.start == q.end {
		q.empty = false
	}
}

//队列弹出队头
func (q *Queue) Poll() int {
	//说明队列空
	if q.start == q.end && q.empty {
		log.Println("弹出队头------------>没有队头，队列为空")

		return -1
	}

	val := q.data[q.start]
	q.start++
	if q.start == q.end {
		q.empty = true
	}
	return val
}

//队列查看队头
func (q *Queue) Peek() int {
	//没有队头
	//说明队列空
	if q.start == q.end && q.empty {
		log.Println("查看队头------------>没有队头，队列为空")
		return -1
	}
	return q.data[q.start]
}

func main() {
	q := &Queue{
		start: 0,
		end: 0,
		empty: true,
	}

	q.Push(1)
	q.Push(2)
	q.Push(3)
	q.Push(4)
	q.Push(5)
	q.Push(6)
	fmt.Println(q.data)
	fmt.Println(q.Poll())
	fmt.Println(q.Poll())

}
```
{% endfolding %}

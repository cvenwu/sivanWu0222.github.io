---
title: （算法）小和问题
author: yirufeng
top: true
toc: true
mathjax: false
summary: 找到一个数左边比他所有小的数的和，累加起来就是小和
categories: 
  - 算法
tags:
  - 归并排序
  - 小和问题
date: 2020-09-23 17:14:01
---
{% note info, 使用归并排序来对小和问题进行求解 %}
## 步骤
因为归并排序已经将数组分成了两个已经有序的子数组，我们要想统计小和的个数，我们就需要在merge的过程中统计小和的个数。

假设本次要merge两个子数组为num1, num2。分别为num的左右两个子数组，其中num1的下标从0到mid,num2的下标从mid+1到right
1. 如果每次合并的时候num2中的元素num2[j]小于num1中的元素num1[i]，此时会产生小和
   1. 对于num1中的元素num1[i]，此时比它大的有num2中的第j个元素之后的所有元素(包括num2的第j个元素)。这里我们不考虑num1中比num1[i]大的元素，因为我们在生成有序num1的时候就已经考虑过了。
   2. 所以此时num2中大于num1[i]元素个数为（r-j+1），但是要统计小和，所以我们让之前统计小和的结果加上`（r-j+1）* num1[i]`
   3. 不断循环，知道整个数组都已经归并完成
2. 上面第1步是合并了num的从l到j的元素，但是我们还要不断递归

## 几个关键点
1. `return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r)` 这里是我们统计左边半个数组内部的小和以及右边半个数组内部的小和，以及左右两个子数组合并时候产生的小和
   
2. {% note info, `ret += (r-j+1) * nums[i]` 因为是要求小和，所以我们统计出了比num[i]小的元素个数为(r-j+1)个，最后还是要乘以nums[i]来获取nums[i]的两个数组之间的小和 %}
<!-- more -->	
## 具体实现

```go
package main

import (
	sorts "InterviewQuestions/Algo/sort"
	"fmt"
)

/**
 * @Author: yirufeng
 * @Email: yirufeng@foxmail.com
 * @Date: 2020/9/23 5:03 下午
 * @Desc: 计算小和的个数
 */

func MergeSort(nums []int) int {
	if nums == nil || len(nums) < 2 {
		return 0
	}
	return mergeSort(nums, 0, len(nums)-1)
}

func mergeSort(nums []int, l, r int) int {
	//递归结束条件
	if l == r {
		return 0
	}

	//注意这个写法：可以避免越界同时使用>>1加速运算
	mid := l + (r-l)>>1
	//分治
	return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r)
}

func merge(nums []int, l, mid, r int) int {
	i, j := l, mid+1
	//申请一个辅助数组
	help := make([]int, r-l+1)
	index := 0
	ret := 0
	//谁小填谁移谁
	for i <= mid && j <= r {
		if nums[i] >= nums[j] {
			help[index] = nums[j]
			j++
		} else {  //此时产生小和
			//计算小和的关键一步，当前比较nums[i]与nums[j]，
			//此时nums[i]<nums[j]比nums[i]大的有nums数组中从第j个到第r个一共r-j+1
			//相当于每次都在左边那个数组中的元素：找到右边数组中有多少个元素比他大，之后乘以该元素的值。
			//重复如上步骤不断累加便是我们的小和
			ret += (r-j+1) * nums[i]
			help[index] = nums[i]
			i++
		}
		index++
	}

	//移动剩下的一部分
	//注意下面两个是for循环，不是if
	//另外注意的是下面两个for循环有且只有一个可以被执行
	for i <= mid {
		help[index] = nums[i]
		index++
		i++
	}

	for j <= r {
		help[index] = nums[j]
		index++
		j++
	}

	//此时help已经填充好我们排序后的数字了，我们需要将且拷贝到原数组的l->r
	for i := l; i <= r; i++ {
		nums[i] = help[i-l]
	}

	return ret
}

func main() {
	nums := sorts.RandArrayRange(6,  0, 100)
	fmt.Println(nums)
	fmt.Println(MergeSort(nums))
}
```
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c语言中日期字符串转换为时间戳</title>
      <link href="/2022/09/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3/"/>
      <url>/2022/09/28/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%B6%E9%97%B4%E6%88%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串与时间戳的转换"><a href="#字符串与时间戳的转换" class="headerlink" title="字符串与时间戳的转换"></a>字符串与时间戳的转换</h2><h3 id="日期字符串转换为时间戳"><a href="#日期字符串转换为时间戳" class="headerlink" title="日期字符串转换为时间戳"></a>日期字符串转换为时间戳</h3><p>思路：</p><ol><li>将日期字符串转换为时间结构体</li><li>将时间结构体转换为对应的时间戳(<code>time_t</code>类型，其实是<code>long</code>类型的别名)</li></ol><details cyan open><summary> 日期字符串转换为时间戳 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">convertDateToTimestamp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 首先在后面添加时间</span></span><br><span class="line">    <span class="keyword">char</span> dateTimeBuf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(dateTimeBuf, <span class="keyword">sizeof</span>(dateTimeBuf), <span class="string">&quot;%s 00:00:00&quot;</span>, date.c_str());</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTM</span>;</span></span><br><span class="line">    strptime(dateTimeBuf, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dateTM);</span><br><span class="line">    <span class="keyword">return</span> mktime(&amp;dateTM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="日期时间字符串转换为时间戳"><a href="#日期时间字符串转换为时间戳" class="headerlink" title="日期时间字符串转换为时间戳"></a>日期时间字符串转换为时间戳</h3><p>思路：</p><ol><li>将日期字符串转换为时间结构体</li><li>将时间结构体转换为对应的时间戳(<code>time_t</code>类型，其实是<code>long</code>类型的别名)</li></ol><details green><summary> 日期时间字符串转换为时间戳 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期时间字符串转换为对应的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">convertDatetimeToTimestamp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;date_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dtTM</span>;</span></span><br><span class="line">    strptime(date_time.c_str(), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dtTM);</span><br><span class="line">    <span class="keyword">return</span> mktime(&amp;dtTM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="时间戳转换为日期字符串"><a href="#时间戳转换为日期字符串" class="headerlink" title="时间戳转换为日期字符串"></a>时间戳转换为日期字符串</h3><p>思路：</p><ol><li>将时间戳转换为<code>struct tm</code>类型的时间：使用<code>localtime_r</code>函数或者<code>localtime</code>函数</li><li>然后将<code>struct tm</code>类型的时间按照给定格式化串格式化为字符串：使用<code>strftime</code>函数</li></ol><details green><summary> 时间戳转换为日期字符串 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳转换为日期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTimestampToDate</span><span class="params">(<span class="keyword">time_t</span> timestamp, <span class="built_in">string</span> &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将时间戳转换为struct tm类型:</span></span><br><span class="line">    <span class="comment">// localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTm</span>;</span></span><br><span class="line">    localtime_r(&amp;timestamp, &amp;dateTm);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\n&quot;</span>, dateTm.tm_year + <span class="number">1900</span>, dateTm.tm_mon + <span class="number">1</span>,</span><br><span class="line">           dateTm.tm_mday);</span><br><span class="line">    <span class="comment">// 2. 将struct tm类型转换为自定义格式化字符串</span></span><br><span class="line">    <span class="keyword">char</span> dateBuf[<span class="number">16</span>];</span><br><span class="line">    strftime(dateBuf, <span class="keyword">sizeof</span>(dateBuf), <span class="string">&quot;%Y-%m-%d&quot;</span>, &amp;dateTm);</span><br><span class="line">    date = dateBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="时间戳转换为日期时间字符串"><a href="#时间戳转换为日期时间字符串" class="headerlink" title="时间戳转换为日期时间字符串"></a>时间戳转换为日期时间字符串</h3><p>思路：</p><ol><li>将时间戳转换为<code>struct tm</code>类型的时间：使用<code>localtime_r</code>函数或者<code>localtime</code>函数</li><li>然后将<code>struct tm</code>类型的时间按照给定格式化串格式化为字符串：使用<code>strftime</code>函数</li></ol><details green><summary> 时间戳转换为日期时间字符串 </summary>              <div class='content'>              <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳转换为日期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTimestampToDatetime</span><span class="params">(<span class="keyword">time_t</span> timestamp, <span class="built_in">string</span> &amp;date_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将时间戳转换为struct tm类型:</span></span><br><span class="line">    <span class="comment">// localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTimeTm</span>;</span></span><br><span class="line">    localtime_r(&amp;timestamp, &amp;dateTimeTm);</span><br><span class="line">    <span class="comment">// 2. 将struct tm类型转换为自定义格式化字符串</span></span><br><span class="line">    <span class="keyword">char</span> dateTimeBuf[<span class="number">32</span>];</span><br><span class="line">    strftime(dateTimeBuf, <span class="keyword">sizeof</span>(dateTimeBuf), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,</span><br><span class="line">             &amp;dateTimeTm);</span><br><span class="line">    date_time = dateTimeBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><span id="more"></span><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://mp.weixin.qq.com/s/y4Oe0gZ0_rwwW3XcdwJg7w">【C语言笔记】时间日期函数</a></li><li><a href="https://mp.weixin.qq.com/s/LsQXRqq7SZqI_y45O_0g3Q">【笔记】整理C语言的时间函数</a></li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期字符串转换为对应的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">convertDateToTimestamp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 首先在后面添加时间</span></span><br><span class="line">    <span class="keyword">char</span> dateTimeBuf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(dateTimeBuf, <span class="keyword">sizeof</span>(dateTimeBuf), <span class="string">&quot;%s 00:00:00&quot;</span>, date.c_str());</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTM</span>;</span></span><br><span class="line">    strptime(dateTimeBuf, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dateTM);</span><br><span class="line">    <span class="keyword">return</span> mktime(&amp;dateTM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期时间字符串转换为对应的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">convertDatetimeToTimestamp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;date_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dtTM</span>;</span></span><br><span class="line">    strptime(date_time.c_str(), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dtTM);</span><br><span class="line">    <span class="keyword">return</span> mktime(&amp;dtTM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转换为日期</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTimestampToDate</span><span class="params">(<span class="keyword">time_t</span> timestamp, <span class="built_in">string</span> &amp;date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将时间戳转换为struct tm类型:</span></span><br><span class="line">    <span class="comment">// localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTm</span>;</span></span><br><span class="line">    localtime_r(&amp;timestamp, &amp;dateTm);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\n&quot;</span>, dateTm.tm_year + <span class="number">1900</span>, dateTm.tm_mon + <span class="number">1</span>,</span><br><span class="line">           dateTm.tm_mday);</span><br><span class="line">    <span class="comment">// 2. 将struct tm类型转换为自定义格式化字符串</span></span><br><span class="line">    <span class="keyword">char</span> dateBuf[<span class="number">16</span>];</span><br><span class="line">    strftime(dateBuf, <span class="keyword">sizeof</span>(dateBuf), <span class="string">&quot;%Y-%m-%d&quot;</span>, &amp;dateTm);</span><br><span class="line">    date = dateBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转换为日期时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTimestampToDatetime</span><span class="params">(<span class="keyword">time_t</span> timestamp, <span class="built_in">string</span> &amp;date_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 将时间戳转换为struct tm类型:</span></span><br><span class="line">    <span class="comment">// localtime是不可重入函数，非线程安全，但是localtime_r是可重入函数，线程安全的</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTimeTm</span>;</span></span><br><span class="line">    localtime_r(&amp;timestamp, &amp;dateTimeTm);</span><br><span class="line">    <span class="comment">// 2. 将struct tm类型转换为自定义格式化字符串</span></span><br><span class="line">    <span class="keyword">char</span> dateTimeBuf[<span class="number">32</span>];</span><br><span class="line">    strftime(dateTimeBuf, <span class="keyword">sizeof</span>(dateTimeBuf), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,</span><br><span class="line">             &amp;dateTimeTm);</span><br><span class="line">    date_time = dateTimeBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, convertDateToTimestamp(<span class="string">&quot;2022-09-23&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, convertDatetimeToTimestamp(<span class="string">&quot;2022-09-23 15:23:59&quot;</span>));</span><br><span class="line">    <span class="built_in">string</span> date;</span><br><span class="line">    <span class="built_in">string</span> date_time;</span><br><span class="line">    convertTimestampToDate(<span class="number">1663917839</span>, date);</span><br><span class="line">    convertTimestampToDatetime(<span class="number">1663917839</span>, date_time);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, date.c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, date_time.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>consul集群搭建</title>
      <link href="/2021/05/17/consul%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/05/17/consul%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="consul环境搭建"><a href="#consul环境搭建" class="headerlink" title="consul环境搭建"></a>consul环境搭建</h2><h3 id="方法一：docker安装consul集群"><a href="#方法一：docker安装consul集群" class="headerlink" title="方法一：docker安装consul集群"></a>方法一：docker安装consul集群</h3><details green><summary> 自己动手采用docker搭建一个consul集群 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载最新的consul镜像</span></span><br><span class="line">docker pull consul</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动我们的第一个consul节点</span></span><br><span class="line">docker run --name consul1 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 2 -ui -bind=0.0.0.0 -client=0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取我们第一个启动节点的ip地址：会输出一个ip地址</span></span><br><span class="line">docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; consul1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动第二个consul节点</span></span><br><span class="line">docker run --name consul2 -d -p 8501:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动第三个consul节点</span></span><br><span class="line">docker run --name consul3 -d -p 8502:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>之后访问<code>localhost:8050</code>就可以进入到我们的consul可视化界面</p>              </div>            </details><h3 id="方法二：本机-mac-安装consul："><a href="#方法二：本机-mac-安装consul：" class="headerlink" title="方法二：本机(mac)安装consul："></a>方法二：本机(mac)安装consul：</h3><ol><li>直接进入<a href="https://www.consul.io/downloads">consul官网</a>，下载可执行文件，然后解压到<code>$HOME/Library/consul/</code></li><li>同时将路径加入到我们的系统环境变量<code>~/.bash_profile</code>中<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add consul</span></span><br><span class="line">export PATH=$PATH:$GOPATH/bin:$HOME/Library/consul</span><br></pre></td></tr></table></figure></li><li>然后刷新我们的配置，此时使用consul执行命令<code>consul members</code>来查看我们docker搭建的consul集群</li></ol><h3 id="consul相关命令补充："><a href="#consul相关命令补充：" class="headerlink" title="consul相关命令补充："></a>consul相关命令补充：</h3><ol><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/vtxNib.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/vtxNib.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="vtxNib"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zT7xfI.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zT7xfI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="zT7xfI"></li></ol><h3 id="consul参考资料："><a href="#consul参考资料：" class="headerlink" title="consul参考资料："></a>consul参考资料：</h3><ol><li><a href="https://www.liangxiansen.cn/2017/04/06/consul">参考1</a></li><li><a href="https://blog.csdn.net.yuanyuanispeak/article/details/54880743">参考2</a></li><li><a href="https://www.jianshu.com/p/0fe826b7017f">docker安装consul集群</a></li></ol><span id="more"></span><h3 id="了解服务发现："><a href="#了解服务发现：" class="headerlink" title="了解服务发现："></a>了解服务发现：</h3><p>在微服务编码中我们服务经常会遇到如下的问题：</p><ol><li>客户端连接服务器的时候，IP去掉将无法连接服务器：<code>conn, err := grpc.Dial(&quot;127.0.0.1:10086&quot;, grpc.WithInsecure()</code></li><li>如果先运行客户端再运行服务端，客户端将会报错。</li></ol><p>这些问题都需要解决，因此我们需要通过服务发现来解决这些问题</p><ol><li>通过服务发现来管理服务：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/7pI3Um.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/7pI3Um.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="7pI3Um"></li><li>consul的代码并没有开源：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/hjwDSP.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/hjwDSP.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="hjwDSP"></li><li>故障检测使得如果有服务挂掉，之后请求的时候将会停止访问我们的服务</li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/25Ol7t.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/25Ol7t.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="25Ol7t"></li><li>服务注册：就是服务主动去consul那里登记，服务发现就是指请求过来之后去consul那里查询对应的服务，此时就是服务发现</li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/m7vwPH.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/m7vwPH.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="m7vwPH"> </li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zlqs9v.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zlqs9v.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="zlqs9v"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/gbYtWf.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/gbYtWf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="gbYtWf"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/BoFnOg.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/BoFnOg.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="BoFnOg"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Nbh3Ph.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Nbh3Ph.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Nbh3Ph"></li></ol><h3 id="consul概念"><a href="#consul概念" class="headerlink" title="consul概念"></a>consul概念</h3><ol><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/J2kwru.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/J2kwru.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="J2kwru"></li><li>consul命令参数：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/vtxNib.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/vtxNib.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="vtxNib"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zT7xfI.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zT7xfI.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="zT7xfI"></li></ol><h3 id="consul常用命令"><a href="#consul常用命令" class="headerlink" title="consul常用命令"></a>consul常用命令</h3><ol><li>查看集群成员：<code>consul members</code> <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Pvx6iX.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Pvx6iX.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Pvx6iX">  <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/GYuxXb.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/GYuxXb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GYuxXb"></li><li>查看consul版本：<code>consul version</code></li><li><code>consul leave</code> 用于退出集群</li><li>停止Agent：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NEl3cO.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/NEl3cO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="NEl3cO"></li></ol><h3 id="虚拟机搭建consul集群搭建"><a href="#虚拟机搭建consul集群搭建" class="headerlink" title="虚拟机搭建consul集群搭建"></a>虚拟机搭建consul集群搭建</h3><blockquote><p>环境：3个虚拟机</p></blockquote><ol><li>192.168.110.123</li><li>192.168.110.148</li><li>192.168.110.124</li></ol><p>步骤：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/FjtqZl.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/FjtqZl.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="FjtqZl"></p><ol><li>192.168.110.123 主机执行命令：<code>consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -bind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -client 0.0.0.0</code> <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VNkw1J.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VNkw1J.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="VNkw1J"></li><li>192.168.110.148 主机执行命令：<code>consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -bind=192.168.110.148 -ui -rejoin -join 192.168.110.123</code>  <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VnyBD7.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/VnyBD7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="VnyBD7"> ： <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/URYZtv.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/URYZtv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="URYZtv">   访问：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/94F8s8.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/94F8s8.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="94F8s8"></li><li>148机器访问：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/TppyO2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/TppyO2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="TppyO2"></li><li>192.168.110.124主机执行命令： <code>consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir /etc/consuld.d -rejoin -join 192.168.110.123</code> + <img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/qFexDB.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/qFexDB.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="qFexDB"></li><li>148机器访问：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/RbrG6L.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/RbrG6L.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="RbrG6L"></li></ol><h3 id="consul-服务注册"><a href="#consul-服务注册" class="headerlink" title="consul 服务注册"></a>consul 服务注册</h3><ol><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/tp72FN.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/tp72FN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="tp72FN"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1fRIrx.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1fRIrx.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1fRIrx"></li><li>测试程序：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1J8DIk.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1J8DIk.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1J8DIk"></li></ol><p>在micro中我们不需要手动写consul的配置文件</p><h3 id="consul扩展"><a href="#consul扩展" class="headerlink" title="consul扩展"></a>consul扩展</h3><ol><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/xv7foa.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/xv7foa.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="xv7foa"></li><li>consul架构图：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/UwSjSy.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/UwSjSy.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="UwSjSy"> 如果要跨域（图中的黑色）：通过网络进行连接。</li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/9ZWjlz.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/9ZWjlz.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="9ZWjlz"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/JPZ2Ag.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/JPZ2Ag.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="JPZ2Ag"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zU0oLv.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/zU0oLv.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="zU0oLv"></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/c6644fa98b8a">Consul节点创建与集群的搭建（含单机多节点集群）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> consul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装docker</title>
      <link href="/2021/03/30/centos7%E5%AE%89%E8%A3%85docker/"/>
      <url>/2021/03/30/centos7%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<div class="note warning"><p>系统要求：docker支持64位Centos7，并且要求内核版本(查看Linux系统内核版本：<code>uname -r</code>)不低于3.10</p></div><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><details green><summary> 卸载旧版本 </summary>              <div class='content'>              <div class="note info"><p>旧版本的docker称为docker或docker-engine，使用如下命令卸载旧版本</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>              </div>            </details><details green><summary> 安装方式一：使用yum安装 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><div class="note info"><p>如果执行之后返回的是没有可用软件包，此时我们需要安装必要的软件依赖以及更新增加docker-ce yum源</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>执行完这两条命令之后我们便可以重新执行`sudo yum install docker-ce`进行安装              </div>            </details><details green><summary> 安装方式二：使用脚本安装 </summary>              <div class='content'>              <div class="note info"><p>在测试或开发环境中docker官方为了简化安装流程，提供了一套便捷的安装脚本，centos系统上可以使用这套脚本进行安装</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>执行完这个命令之后，系统会自动将一切工作准备好，并把docker ce的Edge版本安装在系统中              </div>            </details><span id="more"></span><details green><summary> 启动docker CE </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>启动docker之后可以使用<code>docker info</code>来查看docker的信息</p>              </div>            </details><details green><summary> 建立docker用户组 </summary>              <div class='content'>              <p>默认情况下，docker命令会用Unix Socket与Docker引擎通讯，但是只有root用户与docker组的用户才可以访问Docker引擎的Unix Socket。一般Linux系统上不会直接使用root用户进行操作，因此需要将使用docker的用户加入docker用户组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker #建立 docker 用户s组</span><br><span class="line">sudo usermod -aG docker $&#123;USER&#125; #将当前用户加入docker用户组</span><br></pre></td></tr></table></figure><p>启动docker之后可以使用<code>docker info</code>来查看docker的信息</p>              </div>            </details><details green><summary> 测试docker是否正确安装 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world #启动一个基于hello-world的镜像的容器</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="配置docker镜像加速器"><a href="#配置docker镜像加速器" class="headerlink" title="配置docker镜像加速器"></a>配置docker镜像加速器</h2><p>docker默认从docker hub上拉取镜像，国内会网速偏慢，建议配置镜像加速器</p><details green><summary> 步骤 </summary>              <div class='content'>              <ol><li>在/etc/docker/daemon.json文件(如果没有就创建)中写入：这里配置的是自己的阿里云的，建议配置阿里云的（[获取镜像加速器地址](<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors%EF%BC%89">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors）</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;*(涉密省略)**.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>重新启动服务生效<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li>查看一下docker默认下载镜像的地址：执行<code>docker info</code> ，查看Registry Mirrors的内容是否为我们配置的内容。如下图所示：<img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/pODGrE.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/pODGrE.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pODGrE"></li></ol>              </div>            </details><h2 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h2><details green><summary> 删除docker安装包 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker-ce</span><br></pre></td></tr></table></figure>              </div>            </details><details green><summary> 删除docker镜像 </summary>              <div class='content'>              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> docker </tag>
            
            <tag> Tools </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个全排列的题目</title>
      <link href="/2020/11/28/%E4%B8%A4%E4%B8%AA%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E9%A2%98%E7%9B%AE/"/>
      <url>/2020/11/28/%E4%B8%A4%E4%B8%AA%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h2><p><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/ZWdEW0.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/ZWdEW0.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="ZWdEW0"></p><span id="more"></span><div class="note "><p><strong>思路</strong></p><ol><li>每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束</li><li>但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，我们从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，</li><li>之后进行下一层的递归</li><li>最后递归回来之后，我们再交换回去</li></ol></div><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="comment">//核心：如何做到每次从后面的选择，并且不会重复呢？如果后面选择某个元素，我们就把该元素交换到我们已经选择完的下一个元素</span></span><br><span class="line"><span class="comment">//index表示下次从nums中的哪个位置元素开始，因为之前的都已经选好了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(ret *[][]<span class="keyword">int</span>, path []<span class="keyword">int</span>, index <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line"><span class="comment">//将当前路径加入到结果中</span></span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line"><span class="built_in">copy</span>(temp, path)</span><br><span class="line">*ret = <span class="built_in">append</span>(*ret, temp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始进入选择</span></span><br><span class="line"><span class="keyword">for</span> i := index; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">//利用交换，让我们每次选择的都放置到上次选择的后面那个相邻元素</span></span><br><span class="line">nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line"><span class="comment">//下次我们将index位置的元素加入路径</span></span><br><span class="line">path = <span class="built_in">append</span>(path, nums[index])</span><br><span class="line"><span class="comment">//进入下一层</span></span><br><span class="line">backtrack(ret, path, index+<span class="number">1</span>, nums)</span><br><span class="line"><span class="comment">//从路径中撤销</span></span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">//撤销交换</span></span><br><span class="line">nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret [][]<span class="keyword">int</span></span><br><span class="line">backtrack(&amp;ret, []<span class="keyword">int</span>&#123;&#125;, <span class="number">0</span>, nums)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h2><p><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/oBMXGf.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/oBMXGf.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="oBMXGf"></p><div class="note info"><p>note info 核心：如何避免重复出现。思路：我们使用一个map或者set来统计index位置，我们已经交换过的元素，如果下次要交换的元素与我们之前交换过的元素的元素值相同则跳过，<strong>因此我们可以使用map或者set来统计。但是要注意位置，每次递归进来的时候我们都要重新建立针对当前index位置的一个统计容器</strong></p></div><div class="note "><p><strong>思路</strong></p><ol><li>每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束</li><li>但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，如果放置的元素与我们之前放置过的元素不重复，那么我们将从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，</li><li>之后进行下一层的递归</li><li>最后递归回来之后，我们再交换回去</li></ol></div><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret [][]<span class="keyword">int</span></span><br><span class="line">backtrack(nums, &amp;ret, <span class="number">0</span>, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums []<span class="keyword">int</span>, ret *[][]<span class="keyword">int</span>, index <span class="keyword">int</span>, path []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(path) &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"><span class="built_in">copy</span>(temp, path)</span><br><span class="line">*ret = <span class="built_in">append</span>(*ret, temp)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := index; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有被访问过</span></span><br><span class="line"><span class="keyword">if</span> !visited[nums[i]] &#123;</span><br><span class="line">nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入路径以及visited中</span></span><br><span class="line">path = <span class="built_in">append</span>(path, nums[index])</span><br><span class="line">visited[nums[index]] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入到下一层</span></span><br><span class="line">backtrack(nums, ret, index+<span class="number">1</span>, path)</span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销加入路径以及撤销加入visited中</span></span><br><span class="line">path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//❌</span></span><br><span class="line"><span class="comment">//下面这一行代码是不需要的，因为当前可选的数字如果选了加入到visited下次我们就不可以再选了，所以不可以再撤销了</span></span><br><span class="line"><span class="comment">//delete(visited, nums[index])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//撤销交换</span></span><br><span class="line">nums[i], nums[index] = nums[index], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的序列化与反序列化</title>
      <link href="/2020/11/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/11/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列化：二叉树被记录成文件的过程叫做序列化</p><p>反序列化：通过文件内容重建原来二叉树的过程叫做反序列化</p><span id="more"></span><h2 id="第一种方式：先序遍历"><a href="#第一种方式：先序遍历" class="headerlink" title="第一种方式：先序遍历"></a>第一种方式：先序遍历</h2><details green><summary> 先序遍历进行序列化和反序列化 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：使用先序遍历进行序列化和反序列化</span></span><br><span class="line"><span class="comment">//进行序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderSerialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;#!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">ret += strconv.Itoa(root.Val) + <span class="string">&quot;!&quot;</span></span><br><span class="line">ret += PreorderSerialize(root.Left)</span><br><span class="line">ret += PreorderSerialize(root.Right)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderDeserialize</span><span class="params">(ret <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">strs := strings.Split(ret, <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题</span></span><br><span class="line"><span class="comment">//所以这里我们传递的是切片的地址</span></span><br><span class="line"><span class="comment">//因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变</span></span><br><span class="line">root := ReconstructTreeFromPreorder(&amp;strs)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据我们分割后的字符串建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReconstructTreeFromPreorder</span><span class="params">(strs *[]<span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (*strs)[<span class="number">0</span>] == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line">(*strs) = (*strs)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先将该值对应的字符串转换为int</span></span><br><span class="line">val, _ := strconv.Atoi((*strs)[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//建立一个针对于该值的节点</span></span><br><span class="line">node := &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉我们建立过的节点的值</span></span><br><span class="line">(*strs) = (*strs)[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">//之后进行递归建立左右子树</span></span><br><span class="line">node.Left = ReconstructTreeFromPreorder(strs)</span><br><span class="line">node.Right = ReconstructTreeFromPreorder(strs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="第二种方式：层次遍历"><a href="#第二种方式：层次遍历" class="headerlink" title="第二种方式：层次遍历"></a>第二种方式：层次遍历</h2><h3 id="自己写的层次遍历序列化"><a href="#自己写的层次遍历序列化" class="headerlink" title="自己写的层次遍历序列化"></a>自己写的层次遍历序列化</h3><details green><summary> 层次遍历进行序列化和反序列化 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//方法二：使用层次遍历进行序列化和反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderSerialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">//首先如果根节点为空，我们直接返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;#!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//首先弹出一个节点</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果弹出的节点不为空，我们直接将值转换为字符串并加入其中</span></span><br><span class="line"><span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">ret += strconv.Itoa(node.Val) + <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret += <span class="string">&quot;#!&quot;</span></span><br><span class="line"><span class="comment">//这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderDeserialize</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">strs := strings.Split(str, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">root := LevelOrderReconstruct(strs)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据层次遍历重建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderReconstruct</span><span class="params">(strs []<span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> head *TreeNode</span><br><span class="line"><span class="comment">//一进来首先建立根节点</span></span><br><span class="line"><span class="keyword">if</span> strs[<span class="number">0</span>] == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">val, _ := strconv.Atoi(strs[<span class="number">0</span>])</span><br><span class="line">head = &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点</span></span><br><span class="line"><span class="comment">//因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点</span></span><br><span class="line">index := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个队列将我们后面需要建立子树的非空节点加入进来，</span></span><br><span class="line">queue := []*TreeNode&#123;head&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//说明当前开始建立cur的左右子树</span></span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立左子树</span></span><br><span class="line"><span class="keyword">if</span> strs[index] == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line">cur.Left = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">val, _ := strconv.Atoi(strs[index])</span><br><span class="line">cur.Left = &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立右子树</span></span><br><span class="line"><span class="keyword">if</span> strs[index] == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line">cur.Right = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">val, _ := strconv.Atoi(strs[index])</span><br><span class="line">cur.Right = &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="参考左神代码：对层次遍历进行序列化和反序列化的改进"><a href="#参考左神代码：对层次遍历进行序列化和反序列化的改进" class="headerlink" title="参考左神代码：对层次遍历进行序列化和反序列化的改进"></a>参考左神代码：对层次遍历进行序列化和反序列化的改进</h3><blockquote><p>加入了一个函数generateNodeFromString避免代码臃肿</p></blockquote><details green><summary> 层次遍历进行序列化和反序列化 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对方法二的改进</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderSerialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">//首先如果根节点为空，我们直接返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;#!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//首先弹出一个节点</span></span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果弹出的节点不为空，我们直接将值转换为字符串并加入其中</span></span><br><span class="line"><span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">ret += strconv.Itoa(node.Val) + <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ret += <span class="string">&quot;#!&quot;</span></span><br><span class="line"><span class="comment">//这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderDeserialize</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">strs := strings.Split(str, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">root := LevelOrderReconstruct(strs)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据层次遍历重建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelOrderReconstruct</span><span class="params">(strs []<span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="comment">//一进来首先建立根节点</span></span><br><span class="line">head := generateNodeFromString(strs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要注意判断一下head是否为空</span></span><br><span class="line"><span class="comment">//注意点：判断head是否为空，如果为空就推出，否则后面会报错的</span></span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点</span></span><br><span class="line"><span class="comment">//因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点</span></span><br><span class="line">index := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个队列将我们后面需要建立子树的非空节点加入进来，</span></span><br><span class="line">queue := []*TreeNode&#123;head&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//说明当前开始建立cur的左右子树</span></span><br><span class="line">cur := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立左子树</span></span><br><span class="line">cur.Left = generateNodeFromString(strs[index])</span><br><span class="line">index++</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立右子树</span></span><br><span class="line">cur.Right = generateNodeFromString(strs[index])</span><br><span class="line">index++</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左子树不为空，加入到队列中</span></span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果右子树不为空，加入到队列中</span></span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateNodeFromString</span><span class="params">(val <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp, _ := strconv.Atoi(val)</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;</span><br><span class="line">Val: temp,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p><a href="www.sivan.tech/2020/11/18/golang%E4%B8%AD%E5%88%B7%E9%A2%98%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/">递归函数传入切片作为参数造成切片修改后递归回来又还原</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 面试 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中刷题关于切片的一些坑</title>
      <link href="/2020/11/18/golang%E4%B8%AD%E5%88%B7%E9%A2%98%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2020/11/18/golang%E4%B8%AD%E5%88%B7%E9%A2%98%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>问题描述：递归的过程中，传递了一个切片作为参数，每次我们都需要对切片切取首元素，之后递归回来的时候发现切片中的元素还是没有切取首元素，<strong>是一个很严重的逻辑错误</strong>。</p><p><strong>问题解决：我们递归函数使用切片作为参数的时候，我们直接传入切片的地址。因为切片每次删除元素，地址也会改变。当切片增加元素引起扩容，地址也会发生改变，而如果只传入切片我们只是引用最开始的时候的切片的地址，因此会发现切片没有任何改变。</strong></p><p>例如我们自己写的二叉树序列化和反序列化代码：在最开始只是传递一个切片，但是后来传递切片的地址进去发现代码逻辑正常运行。</p><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：使用先序遍历进行序列化和反序列化</span></span><br><span class="line"><span class="comment">//进行序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderSerialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;#!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">ret += strconv.Itoa(root.Val) + <span class="string">&quot;!&quot;</span></span><br><span class="line">ret += PreorderSerialize(root.Left)</span><br><span class="line">ret += PreorderSerialize(root.Right)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderDeserialize</span><span class="params">(ret <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">strs := strings.Split(ret, <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题</span></span><br><span class="line"><span class="comment">//所以这里我们传递的是切片的地址</span></span><br><span class="line"><span class="comment">//因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变</span></span><br><span class="line">root := ReconstructTreeFromPreorder(&amp;strs)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据我们分割后的字符串建立二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReconstructTreeFromPreorder</span><span class="params">(strs *[]<span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (*strs)[<span class="number">0</span>] == <span class="string">&quot;#&quot;</span> &#123;</span><br><span class="line">(*strs) = (*strs)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先将该值对应的字符串转换为int</span></span><br><span class="line">val, _ := strconv.Atoi((*strs)[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//建立一个针对于该值的节点</span></span><br><span class="line">node := &amp;TreeNode&#123;</span><br><span class="line">Val: val,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉我们建立过的节点的值</span></span><br><span class="line">(*strs) = (*strs)[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">//之后进行递归建立左右子树</span></span><br><span class="line">node.Left = ReconstructTreeFromPreorder(strs)</span><br><span class="line">node.Right = ReconstructTreeFromPreorder(strs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的三种遍历方式</title>
      <link href="/2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基于递归的遍历"><a href="#基于递归的遍历" class="headerlink" title="基于递归的遍历"></a>基于递归的遍历</h2><span id="more"></span><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><details green><summary> 先序遍历方式1 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✅代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, PreorderTraverse(root.Left)...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, PreorderTraverse(root.Right)...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details green><summary> 先序遍历方式2 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraverseII</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, PreorderTraverse(root.Left)...)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, PreorderTraverse(root.Right)...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details green><summary> 先序遍历错误方式 </summary>              <div class='content'>              <p><del>错误方式</del></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraverseIII</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, root.Val, PreorderTraverseIII(root.Left)..., PreorderTraverseIII(root.Right)...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><details green><summary> 中序遍历 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, InorderTraverse(root.Left)...)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, InorderTraverse(root.Right)...)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><details green><summary> 后序遍历 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraverse</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, PostorderTraverse(root.Left)...)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, PostorderTraverse(root.Right)...)</span><br><span class="line">ret = <span class="built_in">append</span>(ret, root.Val)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="基于非递归的遍历"><a href="#基于非递归的遍历" class="headerlink" title="基于非递归的遍历"></a>基于非递归的遍历</h2><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><ol><li>申请一个新的栈，记为stack，然后将头结点压入到stack中</li><li>从stack中弹出栈顶结点，记为cur，然后打印cur结点的值，再将cur结点的右孩子（不为空）压入到栈中，最后将左孩子（不为空）压入到stack中</li><li>不断重复步骤2，直到stack为空，全部过程结束</li></ol><details green><summary> 非递归实现二叉树的先序遍历 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="comment">//思路：使用栈来求解，初始化的时候若根不为空，则将根加入到栈中，</span></span><br><span class="line"><span class="comment">//之后，每次遍历到一个节点将值加入到结果中并弹出，然后将右子树加入到栈中，之后将左子树加入到栈中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreorderTraverseNoRecursion</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//首先从栈中弹出一个节点</span></span><br><span class="line">node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前节点的值加入到我们要返回的结果中</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, node.Val)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前节点的右节点加入到栈中</span></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前节点的左节点加入到栈中</span></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol><li>申请一个新栈，记为stack。初始时，令变量cur = head</li><li>先把cur节点压入栈中，对以cur节点为头节点的整颗子树来说，依次把左边界压入到栈中，即不停地令cur = cur.Left，然后重复步骤3</li><li>不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点，记为node，打印node的值，并且让cur = node.right，然后继续重复步骤2。</li><li>当stack为空且cur为空，整个过程停止。</li></ol><details green><summary> 非递归实现二叉树的中序遍历 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InorderTraverseNoRecursion</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//如果为空，直接返回</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">cur := root</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//说明当前节点是第一次遍历，直接加入到栈中</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur)</span><br><span class="line"><span class="comment">//之后移动到该节点的左子树节点</span></span><br><span class="line">cur = cur.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//首先从栈中弹出一个节点</span></span><br><span class="line">cur = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">//将当前节点的值加入到结果中</span></span><br><span class="line">ret = <span class="built_in">append</span>(ret, cur.Val)</span><br><span class="line"><span class="comment">//之后移动到当前节点的右节点</span></span><br><span class="line">cur = cur.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h5><p><strong>先介绍用两个栈实现后序遍历的过程，具体过程如下：</strong></p><p>1．申请一个栈，记为s1，然后将头节点head压入s1中。</p><p>2．从s1中弹出的节点记为cur，然后依次将cur的左孩子和右孩子压入s1中。</p><p>3．在整个过程中，每一个从s1中弹出的节点都放进s2中。</p><p>4．不断重复步骤2和步骤3，直到s1为空，过程停止。</p><p>5．从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。”</p><p>通过如上过程我们知道，每棵子树的头节点都最先从s1中弹出，然后把该节点的孩子节点按照先左再右的顺序压入s1，那么从s1弹出的顺序就是先右再左，所以从s1中弹出的顺序就是中、右、左。然后，s2重新收集的过程就是把s1的弹出顺序逆序，所以s2从栈顶到栈底的顺序就变成了左、右、中。</p><details green><summary> 非递归实现二叉树的后序遍历方式1 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="comment">//方法一：使用两个栈实现二叉树的非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraverseNoRecursion</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> stack2 []*TreeNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先我们将root加入到stack1中</span></span><br><span class="line">stack1 := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果stack1不为空</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack1) != <span class="number">0</span> &#123;</span><br><span class="line">cur := stack1[<span class="built_in">len</span>(stack1)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">//将当前节点从栈1移除并且将当前节点加入到栈2</span></span><br><span class="line">stack1 = stack1[:<span class="built_in">len</span>(stack1)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前节点的左右子节点分别加入到栈1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点1：这里有可能左右子节点有可能为空</span></span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">stack1 = <span class="built_in">append</span>(stack1, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">stack1 = <span class="built_in">append</span>(stack1, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//之后将当前节点加入到栈2中</span></span><br><span class="line">stack2 = <span class="built_in">append</span>(stack2, cur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后我们从stack2弹出的顺序就是我们后序遍历得到的结果</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack2) != <span class="number">0</span> &#123;</span><br><span class="line">node := stack2[<span class="built_in">len</span>(stack2)<span class="number">-1</span>]</span><br><span class="line">stack2 = stack2[:<span class="built_in">len</span>(stack2)<span class="number">-1</span>]</span><br><span class="line">ret = <span class="built_in">append</span>(ret, node.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a><strong>第二种方式：</strong></h5><p><strong>最后介绍只用一个栈实现后序遍历的过程，具体过程如下：</strong></p><p>1．申请一个栈，记为stack，将头节点压入stack，同时设置两个变量h和c。在整个流程中，h代表最近一次弹出并打印的节点，c代表”</p><p>摘录来自: 左程云. “程序员代码面试指南:IT名企算法与数据结构题目最优解。” Apple Books. </p><p>“stack的栈顶节点，初始时h为头节点，c为null。</p><p>2．每次令c等于当前stack的栈顶节点，但是不从stack中弹出，此时分以下三种情况。</p><p>①：如果c的左孩子不为null，并且h不等于c的左孩子，也不等于c的右孩子，则把c的左孩子压入stack中。具体解释一下这么做的原因，首先h的意义是最近一次弹出并打印的节点，所以如果h等于c的左孩子或者右孩子，说明c的左子树与右子树已经打印完毕，此时不应该再将c的左孩子放入stack中。否则，说明左子树还没处理过，那么此时将c的左孩子压入stack中。</p><p>②：如果条件①不成立，并且c的右孩子不为null，h不等于c的右孩子，则把c的右孩子压入stack中。含义是如果h等于c的右孩子，说明c的右子树已经打印完毕，此时不应该再将c的右孩子放入stack中。否则，说明右子树还没处理过，此时将c的右孩子压入stack中。</p><p>③：如果条件①和条件②都不成立，说明c的左子树和右子树都已经打印完毕，那么从stack中弹出c并打印，然后令h=c。</p><p>3．一直重复步骤2，直到stack为空，过程停止。”</p><details green><summary> 非递归实现二叉树的后序遍历方式2： </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：只使用一个栈实现二叉树的非递归后序遍历</span></span><br><span class="line"><span class="comment">//✅</span></span><br><span class="line"><span class="comment">//思路：使用一个栈和两个变量，h代表上次访问并删除的节点，c代表当前节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostorderTraverseNoRecursionII</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化的时候h置为root，将c置为nil</span></span><br><span class="line">h := root</span><br><span class="line"><span class="keyword">var</span> c *TreeNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果栈不为空</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line">c = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="comment">//如果当前节点的左子树不为空，并且左右子树都不等于h，说明左子树没有遍历过，将左节点加入栈中</span></span><br><span class="line"><span class="keyword">if</span> c.Left != <span class="literal">nil</span> &amp;&amp; h != c.Left &amp;&amp; h != c.Right &#123;<span class="comment">//也就是第一次遍历该节点的时候</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, c.Left)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.Right != <span class="literal">nil</span> &amp;&amp; c.Right != h &#123; <span class="comment">//如果当前节点的右子树不为空，且不等于h，说明没有遍历过，则将右节点加入到栈中，也就是第二次遍历该节点的时候</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, c.Right)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，弹出节点，并加入到结果中，也就是第三次遍历该节点的时候</span></span><br><span class="line">node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">ret = <span class="built_in">append</span>(ret, node.Val)</span><br><span class="line"><span class="comment">//并且将上一次访问并且打印过的节点重置为node</span></span><br><span class="line">h = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h5 id="【推荐】第三种方式："><a href="#【推荐】第三种方式：" class="headerlink" title="【推荐】第三种方式："></a>【推荐】第三种方式：</h5><blockquote><p>后序遍历是按照左-&gt;右-&gt;根的顺序遍历，我们可以按照根-&gt;右-&gt;左的顺序遍历，然后将我们的结果反转即可。</p></blockquote><details green><summary> 非递归实现二叉树的后序遍历方式3： </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrderTraverseNoRecursion</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">stack := []*TreeNode&#123;root&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照根右左的顺序遍历之后反转我们的结果</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line">cur := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">ret = <span class="built_in">append</span>(ret, cur.Val)</span><br><span class="line"><span class="keyword">if</span> cur.Left != <span class="literal">nil</span> &#123; <span class="comment">//加入左</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur.Right != <span class="literal">nil</span> &#123; <span class="comment">//加入右</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, cur.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转我们的ret</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ret)&gt;&gt;<span class="number">1</span>; i++ &#123;</span><br><span class="line">ret[i], ret[<span class="built_in">len</span>(ret)<span class="number">-1</span>-i] = ret[<span class="built_in">len</span>(ret)<span class="number">-1</span>-i], ret[i]</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFPRT算法-Golang</title>
      <link href="/2020/10/12/BFPRT%E7%AE%97%E6%B3%95-Golang/"/>
      <url>/2020/10/12/BFPRT%E7%AE%97%E6%B3%95-Golang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个BFPRT算法找逻辑Bug找了两天</p></blockquote><p>注意点：</p><ol><li>在找中位数的时候对传入的数组进行排序，这里使用直接插入排序，因为元素个数最多为5，插排常数项极低<ol><li>注意：这里不是<del><code>nums[j] &gt; nums[i]</code></del>而是<code>for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j--</code>，因为后面会对<code>nums[i]</code>造成修改</li></ol></li><li>找中位数数组的中位数<code>medianOfMedians</code>返回的是最终的中位数的值，我们使用这个值进行Partition，<del>自己这里还一直将其当做返回的索引用，导致越界</del></li><li><code>BFPRT</code>函数调用自己的时候，参数一定要对应，<del>自己在写的时候直接将k传入了start</del></li></ol><span id="more"></span><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2><p>其实BFPRT算法与我们之前的快排唯一的区别就在于选择划分元素，之后的partition过程与我们的荷兰国旗划分是一样的。</p><div class="note info"><p>应用场景：无序数组中找到第K小或第K大的数，也可以找到前K大或前K小的数，因为<strong>快速排序的partition长期期望时间复杂度为O(N)，而BFPRT算法的时间复杂度稳定在O(N)</strong></p></div><details green><summary> 具体流程 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/wTcpJO.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/wTcpJO.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="wTcpJO"></p><ol><li>将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，<strong>时间复杂度：O(1)</strong></li><li>组内排序，并将所有数组的中位数组成一个新数组，<strong>时间复杂度：O(N)</strong></li><li>获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)，<strong>时间复杂度：O(N)</strong></li><li>之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归，<strong>时间复杂度：O(7/10 * n)</strong></li></ol>              </div>            </details><div class="note "><p><strong>如何求前k大或者前k小呢？</strong></p><p>这里我们的BFPRT算法返回的是第k小的数，但是如果我们想要返回前k小或者前k大的数，我们需要再对数据进行一次遍历，找到比该数小的，如果不够，再加入该数，直到找到k个为止进行返回，同理前k大的数可以转换为长度-k小的，求出之后按照上述思路求得我们最终的前k大的数即可</p></div><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><blockquote><p>以BFPRT获取第K小的元素为例，例如：直接调用BFPRT(nums, 0, len(nums)-1, 1)找的就是第1小的数也就是最小的数</p></blockquote><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: yirufeng</span></span><br><span class="line"><span class="comment"> * @Email: yirufeng@foxmail.com</span></span><br><span class="line"><span class="comment"> * @Date: 2020/10/12 9:08 上午</span></span><br><span class="line"><span class="comment"> * @Desc: BFPRT算法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">1. 将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，</span></span><br><span class="line"><span class="comment">2. 组内排序，并将所有数组的中位数组成一个新数组</span></span><br><span class="line"><span class="comment">3. 获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)</span></span><br><span class="line"><span class="comment">4. 之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用类似于荷兰国旗问题的划分思路，划分为小于等于与大于三个区间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//l, r分别表示小于target已经有序的区域和大于target已经有序的区域</span></span><br><span class="line">l, r := start<span class="number">-1</span>, end+<span class="number">1</span></span><br><span class="line">cur := start</span><br><span class="line"><span class="keyword">for</span> cur &lt; r &#123;</span><br><span class="line"><span class="keyword">if</span> nums[cur] &gt; target &#123;</span><br><span class="line">nums[r<span class="number">-1</span>], nums[cur] = nums[cur], nums[r<span class="number">-1</span>]</span><br><span class="line">r--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[cur] &lt; target &#123;</span><br><span class="line">nums[cur], nums[l+<span class="number">1</span>] = nums[l+<span class="number">1</span>], nums[cur]</span><br><span class="line">l++</span><br><span class="line">cur++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[cur] == target &#123;</span><br><span class="line">cur++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>, r - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取传入数组nums在start-&gt;end之间的中位数，包括两个边界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMedianOfNums</span><span class="params">(nums []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//对nums[start:end]进行直接插入排序</span></span><br><span class="line"><span class="keyword">var</span> temp, j <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := start + <span class="number">1</span>; i &lt;= end; i++ &#123;</span><br><span class="line">temp = nums[i]</span><br><span class="line"><span class="comment">//注意点1：nums[j] &gt; temp</span></span><br><span class="line"><span class="keyword">for</span> j = i - <span class="number">1</span>; j &gt;= start &amp;&amp; nums[j] &gt; temp; j-- &#123;</span><br><span class="line">nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">&#125;</span><br><span class="line">nums[j+<span class="number">1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[start+(end-start)&gt;&gt;<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选取中位数数组的中位数并进行返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">medianOfMedians</span><span class="params">(nums []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先将传入的数组有效区间内的元素每5个划分为1组，不足5个的不划分</span></span><br><span class="line"><span class="comment">//注意点2：是float64(end - start + 1)不是float64(len(nums))</span></span><br><span class="line">medianNums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="keyword">int</span>(math.Ceil(<span class="keyword">float64</span>(end-start+<span class="number">1</span>)/<span class="number">5.0</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到每个数组的中位数，添加到我们的中位数数组中</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(medianNums); i++ &#123;</span><br><span class="line">val := getMedianOfNums(nums, start+i*<span class="number">5</span>, min(start+i*<span class="number">5</span>+<span class="number">4</span>, end))</span><br><span class="line">medianNums[i] = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回中位数数组的中位数</span></span><br><span class="line"><span class="keyword">return</span> getMedianOfNums(medianNums, <span class="number">0</span>, <span class="built_in">len</span>(medianNums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个参数k表示要第k小的数，所以我们返回第k小的数，其中k从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFPRT</span><span class="params">(nums []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//递归结束条件</span></span><br><span class="line"><span class="keyword">if</span> start == end &#123;</span><br><span class="line"><span class="keyword">return</span> nums[start]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取nums每5个一组后划分的中位数数组的中位数</span></span><br><span class="line"><span class="comment">//之后根据pivot进行partition</span></span><br><span class="line"><span class="comment">//注意点3：这里是medianOfMedians(nums, start, end)而不是nums[medianOfMedians(nums, start, end)]</span></span><br><span class="line"><span class="comment">//因为我们medianOfMedians(nums, start, end)返回的就是划分值</span></span><br><span class="line">l, r := partition(nums, start, end, medianOfMedians(nums, start, end))</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断k是否在划分后的两个索引</span></span><br><span class="line"><span class="keyword">if</span> k &gt;= l &amp;&amp; k &lt;= r &#123;</span><br><span class="line"><span class="keyword">return</span> nums[l]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> k &lt; l &#123;</span><br><span class="line"><span class="keyword">return</span> BFPRT(nums, start, l<span class="number">-1</span>, k)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BFPRT(nums, r+<span class="number">1</span>, end, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>按照沈剑老师的总结：</p><blockquote><p>TopK，不难；其思路优化过程，不简单：</p></blockquote><ol><li>全局排序，O(n*lg(n))</li><li>局部排序，只排序TopK个数，O(n*k)</li><li>堆，TopK个数也不排序了，O(n*lg(k))</li><li>分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))</li><li>减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)</li><li>TopK的另一个解法：随机选择+partition</li><li>本文讲解的bfprt，时间复杂度长期稳定在O(N)</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961587&idx=1&sn=54bf39db7043cc638315caf70f24d94b&chksm=bd2d0d2f8a5a84395246be4522d10fbfc1f744658047d5fb3fad8e9f3c3d76baab3a2ce84867&scene=21#wechat_redirect">参考</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> BFPRT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFPRT </tag>
            
            <tag> topK </tag>
            
            <tag> 找第几大或第几小 </tag>
            
            <tag> 找前几大或前几小 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不基于比较的排序找到数组排序后的最大差值</title>
      <link href="/2020/09/26/%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
      <url>/2020/09/26/%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><div class="note done"><p>给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序</p></div><div class="note info"><p>注意不基于比较哦</p></div><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><details cyan open><summary> 思路：桶排序 </summary>              <div class='content'>              <ol><li>假设数组长度为n，准备n+1个桶</li><li>遍历该数组，将最小值放入到第1个位置，将最大值放入到最后一个位置</li><li>将剩下的数等分成等分成n-1份依次放入剩下对应范围的桶中，</li><li>最后这n+1个桶中至少有一个空桶，说明桶内的数值差不是最大差值，我们去桶间找最大差值</li><li>对于每个桶，我们都保存了每个桶的最小值和最大值，从第2个桶开始，每次计算当前桶的最小值与前一个桶(<strong>要有元素</strong>)的最大值的差，过程中我们动态更新最大差值</li></ol>              </div>            </details><span id="more"></span><h2 id="具体编码"><a href="#具体编码" class="headerlink" title="具体编码"></a>具体编码</h2><details cyan><summary> 实现代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMaxDiff</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">maxNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">minNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">hasNum := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)      <span class="comment">//用来标记桶是否有值</span></span><br><span class="line">min, max := math.MaxInt64, math.MinInt64 <span class="comment">//整个数组的最小值和最大值</span></span><br><span class="line">maxDiff := math.MinInt64                 <span class="comment">//最大差值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找数组的最大值与最小值</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">max = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> min &gt; v &#123;</span><br><span class="line">min = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个位置放最小值，第2个位置放最大值</span></span><br><span class="line">hasNum[<span class="number">0</span>], hasNum[<span class="built_in">len</span>(nums)] = <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line"><span class="comment">//将最大值与最小值之间等分成n(n为数组的长度)-1份，依次遍历属于哪个范围就加入哪个桶</span></span><br><span class="line">diff := <span class="keyword">float64</span>(max-min) / <span class="keyword">float64</span>(<span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">indexBucket := <span class="keyword">int</span>(math.Ceil(<span class="keyword">float64</span>(v-min) / diff))</span><br><span class="line"><span class="comment">//如果当前桶没有值</span></span><br><span class="line"><span class="keyword">if</span> !hasNum[indexBucket] &#123;</span><br><span class="line">maxNum[indexBucket] = v</span><br><span class="line">minNum[indexBucket] = v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当前桶有值且当前桶的最大值小于当前元素 则更新</span></span><br><span class="line"><span class="keyword">if</span> maxNum[indexBucket] &lt; v &#123;</span><br><span class="line">maxNum[indexBucket] = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> minNum[indexBucket] &gt; v &#123;</span><br><span class="line">minNum[indexBucket] = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后将当前桶置为true，说明已放入元素</span></span><br><span class="line">hasNum[indexBucket] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要注意：不是两个相邻的桶之间进行比较</span></span><br><span class="line"><span class="comment">//遍历桶，找当前桶与上一个存放元素的桶的最大差值并返回</span></span><br><span class="line">lastMax := min <span class="comment">//存放上一个最大</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> hasNum[i] &#123;</span><br><span class="line"><span class="keyword">if</span> maxDiff &lt; minNum[i]-lastMax &#123;</span><br><span class="line">maxDiff = minNum[i] - lastMax</span><br><span class="line">&#125;</span><br><span class="line">lastMax = maxNum[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxDiff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := utils.RandArrayRange(<span class="number">10</span>, <span class="number">10</span>, <span class="number">99</span>)</span><br><span class="line">fmt.Println(nums)</span><br><span class="line">fmt.Println(GetMaxDiff(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2020/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序基本知识"><a href="#堆排序基本知识" class="headerlink" title="堆排序基本知识"></a>堆排序基本知识</h2><details green><summary> 基本介绍 </summary>              <div class='content'>              <p>堆是一个完全二叉树，因此我们可以利用节点的特性去使用一个数组模拟一颗完全二叉树：</p><ol><li>下标为i的节点的左子节点的下标为<code>i*2+1</code>, 右子节点的下标为<code>i*2+2</code></li><li>下标为i的节点的父节点的下标为(i-1)/2</li></ol>              </div>            </details><div class="note info"><p>建立堆的时间复杂度：O(log1) + O(log2) + … + O(logN) 近似于 O(N)，因此建立堆的时间复杂度为O(N)</p></div><div class="note info"><p>堆有大根堆以及小根堆，没有规定堆中左子树的根必须大于(或小于)右子树的根。</p></div><details green><summary> 堆排序的两个基本步骤：(具体说明看代码注释) </summary>              <div class='content'>              <ol><li>建堆，循环将数组中的每个数加入堆中（每次都需要heapInsert）</li><li>不断从堆的最后一个元素交换到堆的头部，然后将堆的长度减小1，再调整堆，每次都需要heapify</li></ol>              </div>            </details><span id="more"></span><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><details green><summary> 查看代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">heapSort(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums == <span class="literal">nil</span> || <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立堆的过程</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">heapInsert(nums, i)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;建堆完成---------------&gt;&quot;</span>, nums)</span><br><span class="line">heapSize := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment">//之后不断吐出元素</span></span><br><span class="line"><span class="keyword">for</span> heapSize &gt; <span class="number">0</span> &#123;</span><br><span class="line">nums[<span class="number">0</span>], nums[heapSize<span class="number">-1</span>] = nums[heapSize<span class="number">-1</span>], nums[<span class="number">0</span>]</span><br><span class="line">heapSize--</span><br><span class="line">heapify(nums, heapSize, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于新加入一个元素之后，向上调整堆</span></span><br><span class="line"><span class="comment">//第2个参数表示新加入的元素的下标</span></span><br><span class="line"><span class="comment">//这个过程的时间复杂度为O(N) = O(log1 + log2 + ... + logN) 近似等于 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapInsert</span><span class="params">(nums []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//这里左神说了不用加循环结束条件，因为最终的结束条件就是index为0的时候</span></span><br><span class="line"><span class="comment">//因为-1/2也为0</span></span><br><span class="line"><span class="keyword">for</span> nums[(index<span class="number">-1</span>)/<span class="number">2</span>] &lt; nums[index] &#123;</span><br><span class="line">nums[index], nums[(index<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>] = nums[(index<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>], nums[index]</span><br><span class="line">index = (index - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左老师的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//func heapify(nums []int, heapSize int, index int) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//left := 2*index + 1</span></span><br><span class="line"><span class="comment">//for left &lt; heapSize &#123;</span></span><br><span class="line"><span class="comment">//larger := left</span></span><br><span class="line"><span class="comment">////首先找到左右孩子中最大的</span></span><br><span class="line"><span class="comment">//if left+1 &lt; heapSize &amp;&amp; nums[left] &lt; nums[left+1] &#123;</span></span><br><span class="line"><span class="comment">//larger++</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////这里要注意一下，如果使用一个变量这里可能会溢出，这里我们使用的larger经过了前面的验证</span></span><br><span class="line"><span class="comment">//if nums[larger] &lt;= nums[index] &#123;</span></span><br><span class="line"><span class="comment">//break</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//nums[index], nums[larger] = nums[larger], nums[index]</span></span><br><span class="line"><span class="comment">//index = larger</span></span><br><span class="line"><span class="comment">//left = index*2 + 1</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于将堆顶的元素和堆中最后一个元素交换之后，向下调整堆</span></span><br><span class="line"><span class="comment">//第2个参数为堆的实际大小，因为nums是存放一个数组，</span></span><br><span class="line"><span class="comment">//第3个参数表示该位置元素变动，导致该元素可能要往下沉</span></span><br><span class="line"><span class="comment">//真正的堆是从0-&gt;heapSize-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(nums []<span class="keyword">int</span>, heapSize <span class="keyword">int</span>, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意循环条件</span></span><br><span class="line"><span class="keyword">for</span> i := index; i*<span class="number">2</span>+<span class="number">1</span> &lt; heapSize; &#123;</span><br><span class="line">left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line"><span class="comment">//如果有右并且右比左大</span></span><br><span class="line"><span class="keyword">if</span> left+<span class="number">1</span> &lt; heapSize &amp;&amp; nums[left+<span class="number">1</span>] &gt; nums[left] &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与左右中较大的比较</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &gt;= nums[left] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">i = left</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试问题之Top K系列</title>
      <link href="/2020/09/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8BTop%20K%E7%B3%BB%E5%88%97/"/>
      <url>/2020/09/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8BTop%20K%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="思路整理："><a href="#思路整理：" class="headerlink" title="思路整理："></a>思路整理：</h2><span id="more"></span><details green><summary> 如图所示 </summary>              <div class='content'>              <ol><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/aLjufN.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/aLjufN.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="aLjufN"></li><li><img src="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/b8s2H2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/b8s2H2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="b8s2H2"></li></ol>              </div>            </details><h2 id="几种方法讲解"><a href="#几种方法讲解" class="headerlink" title="几种方法讲解"></a>几种方法讲解</h2><blockquote><p>以剑指offer40题为例，<strong>求最小的k个数字</strong></p></blockquote><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><blockquote><p>思路：直接用最快的排序方法排好序后取前k个或者后k个元素即可</p></blockquote><p>时间复杂度：O(n * logn)<br>空间复杂度：O(1)</p><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> QuickSort(arr)[:k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pivotkey <span class="keyword">int</span></span><br><span class="line"><span class="comment">//优化1：尾递归优化</span></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="comment">//pivotkey 为枢轴防止的最终下标</span></span><br><span class="line">pivotkey = partition(nums, low, high)</span><br><span class="line">quickSort(nums, low, pivotkey<span class="number">-1</span>)</span><br><span class="line">low = pivotkey + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//优化2：使用随机数选择划分枢轴</span></span><br><span class="line"><span class="comment">//设置随机数种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="comment">//选择[0,n)</span></span><br><span class="line"><span class="comment">//rand.Intn(n)</span></span><br><span class="line"><span class="comment">//选择划分元素</span></span><br><span class="line">dummyIndex := rand.Intn(high-low+<span class="number">1</span>) + low</span><br><span class="line"><span class="comment">//将随机选择的元素放置到low位置上，以后便于在高处找到比划分元素小的时候我们可以直接让high赋值给low</span></span><br><span class="line">swap(nums, low, dummyIndex)</span><br><span class="line">dummyVal := nums[low]</span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; dummyVal &lt;= nums[high] &#123;</span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化3：我们使用替换而不是交换</span></span><br><span class="line"><span class="comment">//高处找到小的直接赋值给low</span></span><br><span class="line">nums[low] = nums[high]</span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; dummyVal &gt;= nums[low] &#123;</span><br><span class="line">low++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//低处找到大的直接赋值给high</span></span><br><span class="line">nums[high] = nums[low]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后low == high</span></span><br><span class="line">nums[low] = dummyVal</span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="keyword">int</span>, i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><blockquote><p>思路：冒泡排序每次都会将1个元素放置到最终位置上，我们可以冒泡k趟</p></blockquote><p>时间复杂度：O(k * n)<br>空间复杂度：O(1)</p><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//需要冒泡k次</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= k; i++ &#123;</span><br><span class="line"><span class="comment">//每次从倒数第2个元素开始一直到前面的第i-1个元素，例如第1趟是到第0个(因为每次是和后面的元素进行比较)</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="built_in">len</span>(arr) - <span class="number">2</span>; j &gt;= i<span class="number">-1</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">arr[j+<span class="number">1</span>], arr[j] = arr[j], arr[j+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><blockquote><p>思路：构建一个容量为k的堆，不断遍历数据，插入后进行调整，最后依次返回组合成我们要的结果</p></blockquote><p><strong>适合处理海量数据</strong></p><p>时间复杂度：O(n*logk)<br>空间复杂度：O(K)</p><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Heap Interface</span></span><br><span class="line"><span class="comment">//type Interface interface &#123;</span></span><br><span class="line"><span class="comment">//    sort.Interface</span></span><br><span class="line"><span class="comment">//    Push(x interface&#123;&#125;) // 向末尾添加元素</span></span><br><span class="line"><span class="comment">//    Pop() interface&#123;&#125;   // 从末尾删除元素</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort Interface</span></span><br><span class="line"><span class="comment">//type Interface interface &#123;</span></span><br><span class="line"><span class="comment">//    // Len方法返回集合中的元素个数</span></span><br><span class="line"><span class="comment">//    Len() int</span></span><br><span class="line"><span class="comment">//    // Less方法报告索引i的元素是否比索引j的元素小</span></span><br><span class="line"><span class="comment">//    Less(i, j int) bool</span></span><br><span class="line"><span class="comment">//   // Swap方法交换索引i和j的两个元素</span></span><br><span class="line"><span class="comment">//    Swap(i, j int)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表明是一个小顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> h[i] &lt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> arr &#123;</span><br><span class="line">heap.Push(h, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, heap.Pop(h).(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h3><blockquote><p>思路：随机选择，通过减治的思想利用快速排序中的partition方法可以对我们要求的那个划分轴进行快速选择，</p></blockquote><p>算法导论中提过，我们有成熟的时间复杂度为O(n)的算法来获取任意第k大的数，也就是基于partition的随机选择方法</p><p>时间复杂度：O(N)<br>空间复杂度：O(1)</p><p><strong>会对传入的切片进行修改</strong></p><details green><summary> 代码 </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="keyword">int</span>, start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">index := rand.Intn(end-start+<span class="number">1</span>) + start</span><br><span class="line">val := arr[index]</span><br><span class="line">arr[index], arr[start] = arr[start], arr[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line"><span class="keyword">for</span> start &lt; end &amp;&amp; val &lt;= arr[end] &#123;</span><br><span class="line">end--</span><br><span class="line">&#125;</span><br><span class="line">arr[start] = arr[end]</span><br><span class="line"><span class="keyword">for</span> start &lt; end &amp;&amp; val &gt;= arr[start] &#123;</span><br><span class="line">start++</span><br><span class="line">&#125;</span><br><span class="line">arr[end] = arr[start]</span><br><span class="line">&#125;</span><br><span class="line">arr[start] = val</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> || k &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(arr) &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index := partition(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> index != k<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> index &gt; k<span class="number">-1</span> &#123; <span class="comment">//说明在左边</span></span><br><span class="line">index = partition(arr, <span class="number">0</span>, index<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> index &lt; k<span class="number">-1</span> &#123;</span><br><span class="line">index = partition(arr, index+<span class="number">1</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//到这里说明partition划分为index就是第k个元素，直接返回即可</span></span><br><span class="line"><span class="keyword">return</span> arr[:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="方法四【最优解】：BFPRT"><a href="#方法四【最优解】：BFPRT" class="headerlink" title="方法四【最优解】：BFPRT"></a>方法四【最优解】：BFPRT</h2><p><a href="http://www.sivan.tech/2020/10/12/BFPRT%E7%AE%97%E6%B3%95-Golang/">参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/FFsvWXiaZK96PtUg-mmtEw">58沈剑讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序以及优化</title>
      <link href="/2020/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2020/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>思路：从左向右每次两两比较相邻元素，如果前一个元素大于后一个元素，那么就交换这两个元素，一趟下来肯定有一个元素放到了最后的位置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">bubbleSort(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//从前往后进行交换，每次都会固定好后面的元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line"><span class="comment">//两两比较并交换</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="优化版本的冒泡排序"><a href="#优化版本的冒泡排序" class="headerlink" title="优化版本的冒泡排序"></a>优化版本的冒泡排序</h2><p>思路：前面的冒泡排序在数组已经有序的时候还仍然会比较，因此我们可以通过设置一个flag，如果某一轮没有交换操作，说明当前已经有序，后面的不需要继续比较和判断了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//改进版的冒泡排序：一旦某一趟不交换后面就直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSortV2</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">bubbleSortV2(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortV2</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"><span class="comment">//从前往后进行交换，每次都会固定好后面的元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span> &amp;&amp; flag; i++ &#123;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>-i; j++ &#123;</span><br><span class="line"><span class="comment">//两两比较并交换</span></span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接插入排序以及优化</title>
      <link href="/2020/09/10/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2020/09/10/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><strong>直接插入排序是简单排序中性能最好的</strong></p><p>平均时间复杂度：<code>O(n^n / 4)</code><br>最好时间复杂度：<code>O(n)</code><br>最坏时间复杂度：<code>O(n^n)</code></p><h3 id="直接插入排序版本1"><a href="#直接插入排序版本1" class="headerlink" title="直接插入排序版本1"></a>直接插入排序版本1</h3><p>思路：将每次要插入的当前元素依次与左边元素比较，如果左边元素大于当前元素则交换，直到左边元素小于等于当前元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: yirufeng</span></span><br><span class="line"><span class="comment"> * @Email: yirufeng@foxmail.com</span></span><br><span class="line"><span class="comment"> * @Date: 2020/9/10 9:12 上午</span></span><br><span class="line"><span class="comment"> * @Desc: 直接插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">insertSort(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//思路：如果当前元素比前一个元素小就交换，一直到当前元素大于等于前一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//默认下标为0的已经有序，因此从下标为1的开始插入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">//插入条件：要排序的元素一定要小于前面的元素</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line"><span class="comment">//什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入</span></span><br><span class="line"><span class="keyword">for</span> j := i; j &gt;= <span class="number">1</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; j-- &#123;</span><br><span class="line">nums[j], nums[j<span class="number">-1</span>] = nums[j<span class="number">-1</span>], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个随机数生成器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandArray</span><span class="params">(length <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">nums = <span class="built_in">append</span>(nums, r.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">nums := RandArray(<span class="number">30</span>)</span><br><span class="line">log.Println(nums)</span><br><span class="line">log.Println(InsertSort(nums))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="直接插入排序版本2"><a href="#直接插入排序版本2" class="headerlink" title="直接插入排序版本2"></a>直接插入排序版本2</h3><blockquote><p>摘自&lt;&lt;大话数据结构&gt;&gt;</p></blockquote><p>思路：将前面比要插入元素大的元素挪到后面，<strong>找到插入位置之后将要插入元素插入即可</strong>，最后找到的插入位置一定是j+1而不是j因为我们判断了nums[j]小于等于我们要插入的元素 </p><p><strong>注意：此时要记得将temp放置到正确位置</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Author: yirufeng</span></span><br><span class="line"><span class="comment"> * @Email: yirufeng@foxmail.com</span></span><br><span class="line"><span class="comment"> * @Date: 2020/9/10 9:12 上午</span></span><br><span class="line"><span class="comment"> * @Desc: 直接插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertSortV2</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">insertSortV2(nums)</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大话数据结构书上的直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertSortV2</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//默认下标为0的已经有序，因此从下标为1的开始插入</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="comment">//插入条件：要排序的元素一定要小于前面的元素</span></span><br><span class="line"><span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">temp := nums[i]</span><br><span class="line">j := i<span class="number">-1</span></span><br><span class="line"><span class="comment">//什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入</span></span><br><span class="line"><span class="keyword">for</span> ; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp ; j-- &#123;</span><br><span class="line">nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时要记得将temp放置到正确位置</span></span><br><span class="line">nums[j+<span class="number">1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个随机数生成器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandArray</span><span class="params">(length <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">nums = <span class="built_in">append</span>(nums, r.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//设置随机数种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">nums := RandArray(<span class="number">30</span>)</span><br><span class="line">log.Println(nums)</span><br><span class="line">log.Println(InsertSortV2(nums))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 直接插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo环境搭建(涵盖mac + win)并将我们的博客同步和发布到github</title>
      <link href="/2019/03/21/hexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/03/21/hexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<div class="note warning"><p>如果不想使用nvm进行node多版本的管理，直接可以使用去<a href="http://nodejs.cn/download/">node中文网</a> 下载<strong>LTS版本</strong>(安装的时候记得添加到环境变量选项要勾上)，安装后从第四步开始执行</p></div><h2 id="第一步：安装nvm"><a href="#第一步：安装nvm" class="headerlink" title="第一步：安装nvm"></a>第一步：安装nvm</h2><blockquote><p>这一步mac和windows有所区别</p></blockquote><div class="tabs" id="tab-tab-id"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1">mac</a></li><li class="tab"><a class="#tab-id-2">windows</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><ul><li>执行<code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code> 或 <code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code><ul><li>注意：注意后面的<code>v0.33.8</code>这是nvm的版本号，<a href="https://github.com/coreybutler/nvm-windows/releases">最新版本查看</a></li></ul></li></ul></div><div class="tab-pane" id="tab-id-2"><ul><li>参考<a href="https://www.cnblogs.com/jing-tian/p/11225123.html">Windows下安装及使用nvm</a>在windows下安装nvm</li></ul></div></div></div><ul><li>安装完成后关闭终端，然后键入<code>nvm</code>看一下是否有输出，如果<code>command not found</code>请<a href="https://www.jianshu.com/p/622ad36ee020">查看</a></li><li><code>nvm ls</code>查看所有已安装node的版本，并且使用<code>node use &lt;version&gt;</code>命令选择一个合适的node用来安装hexo</li></ul><p>补充：nvm常用命令介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">● nvm install stable  安装最新稳定版 node</span><br><span class="line">● nvm install &lt;version&gt;  安装指定版本，如：安装v4.4.0，nvm install v4.4.0</span><br><span class="line">● nvm uninstall &lt;version&gt;  删除已安装的指定版本，语法与install类似</span><br><span class="line">● nvm use &lt;version&gt;  切换使用指定的版本node</span><br><span class="line">● nvm ls  列出所有安装的版本</span><br><span class="line">● nvm alias default &lt;version&gt;  如： nvm alias default v11.1.0</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="第二步：卸载原来的hexo"><a href="#第二步：卸载原来的hexo" class="headerlink" title="第二步：卸载原来的hexo"></a>第二步：卸载原来的hexo</h2><ol><li>删除原来的hexo：<code>npm uninstall -g hexo-cli</code></li></ol><h2 id="第三步：安装node"><a href="#第三步：安装node" class="headerlink" title="第三步：安装node"></a>第三步：安装node</h2><blockquote><p>由于hexo必须要用npm安装，hexo安装的版本取决于node的版本</p></blockquote><ol><li>使用nvm选择我们的node版本，如果对应版本没有安装，首先使用nvm安装对应版本的node。<code>nvm install &lt;version&gt;</code></li><li>切换到对应的node版本：<code>npm use &lt;version&gt;</code></li></ol><h2 id="第四步：安装hexo"><a href="#第四步：安装hexo" class="headerlink" title="第四步：安装hexo"></a>第四步：安装hexo</h2><ol><li>安装hexo： <code>npm install -g hexo-cli</code></li></ol><h2 id="第五步：同步并发布自己的博客-CI-CD"><a href="#第五步：同步并发布自己的博客-CI-CD" class="headerlink" title="第五步：同步并发布自己的博客(CI + CD)"></a>第五步：同步并发布自己的博客(CI + CD)</h2><blockquote><p>这里假设我们的博客文章已经编写完成</p></blockquote><p>这一部分涉及到两部分内容：</p><ol><li>(备份)同步博客源内容到github：避免之前编写的博客内容丢失</li><li>(发布)将我们编写的博客发布到github：可以以网页的形式看到我们编写之后的内容</li></ol><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li>在我们的博客根目录下新建<code>.github</code>目录，然后进入<code>.github</code>目录新建<code>workflows</code>目录，进入之后新建<code>deploy.yml</code>文件</li><li>键入如下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name: Build and Deploy</span><br><span class="line">on: </span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - source</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build-and-deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout 🛎️</span><br><span class="line">        uses: actions&#x2F;checkout@v2 # If you&#39;re using actions&#x2F;checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span><br><span class="line">        with:</span><br><span class="line">          persist-credentials: false</span><br><span class="line"></span><br><span class="line">      - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line">          npm run build</span><br><span class="line">        env:</span><br><span class="line">          CI: false</span><br><span class="line"></span><br><span class="line">      - name: Deploy 🚀</span><br><span class="line">        uses: JamesIves&#x2F;github-pages-deploy-action@releases&#x2F;v3</span><br><span class="line">        with:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</span><br><span class="line">          BRANCH: main # The branch the action should deploy to.</span><br><span class="line">          FOLDER: public # The folder the action should deploy.</span><br></pre></td></tr></table></figure></li><li>配置ACCESS_TOKEN<ol><li>进入<a href="https://github.com/settings/tokens">github token页面</a></li><li>点击<code>generate new token</code>全选之后将将生成的token赋值</li><li>进入自己的<code>用户名.github.io</code>仓库，然后点击<code>settings</code>-&gt;<code>secrets</code>-&gt;<code>New repository secret</code>-&gt;名字是<code>ACCESS_TOKEN</code>，值是刚才生成的token</li></ol></li><li>使用git的<code>add</code>、<code>commit</code>、<code>push</code> 命令提交</li></ol><p>注意事项：</p><ul><li>博客的源代码存放到 <code>用户名.github.io</code>这个仓库下的source分支下</li><li>博客的发布流程我们在上面已经配置到了github的action中，github会在我们push到source分支的时候直接拉取代码然后发布到main分支，之后我们就可以通过<code>用户名.github.io</code>这个域名进行访问了</li></ul><p>之后每次提交记得在source分支下操作</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><blockquote><p>博客搭建好之后，只需要选一个合适的主题，就可以书写自己的博客了</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/u013778905/article/details/83501204">GitHub如何配置SSH Key</a></li><li><a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">Hexo-5.x 与 NexT-8.x 跨版本升级</a></li><li><a href="https://www.bilibili.com/video/BV1dt4y1Q7UE?from=search&seid=14792497382015603750">【干货】Luke教你20分钟快速搭建个人博客系列(hexo篇) | 自动化部署在线编辑统统搞定 | 前端必会！</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
